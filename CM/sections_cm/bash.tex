
% ---

\begin{frame}{Langages Compilés vs Langages Interprétés}
  \setbeamercovered{transparent}

  \begin{itemize}
    \setlength\itemsep{1em}

    \item <1-> Langages Compilés
    \begin{itemize}
      \setlength\itemsep{0.5em}
      \footnotesize
      \item <2-> code source traduit en un binaire avant l'exécution
      \item <3-> avantage : performance maximale
      \item <4-> inconvénient : compilation nécessaire à chaque changement
      \item <5-> ex: C, C++, Rust, Fortran, \ldots
    \end{itemize}

    \item <1-> Langages Interprétés / Scripts
    \begin{itemize}
      \setlength\itemsep{0.5em}
      \footnotesize
      \item <2-> le code est lu et exécuté ligne par ligne par un interpréteur
      \item <3-> avantage : développement rapide, pas de compilation
      \item <4-> inconvénient : plus lent à l'exécution
      \item <5-> ex: Bash, Python, Ruby, Perl, \ldots
    \end{itemize}
  \end{itemize}

\end{frame}

% ---

\begin{frame}{Pourquoi écrire des scripts ?}

  \begin{itemize}
    \setlength\itemsep{1em}

    \item[\emoji{robot}] Automatisation : les tâches répétitives sont ennuyeuses et sources d'erreurs
    \begin{itemize}
      \setlength\itemsep{0.5em}
      \footnotesize
      \item sauvegarder dossier \texttt{\color{blue}/Factures} sur un serveur 
            distant tous les soirs avant de quitter le travail
    \end{itemize}

    \pause

    \item[\emoji{link}] "Glu"
    \begin{itemize}
      \setlength\itemsep{0.5em}
      \footnotesize
      \item lancer un calcul en C $\rightarrow$
            récupérer le résultat $\rightarrow$
            générer un graphique avec Python
    \end{itemize}

    \pause

    \item[\emoji{file-folder}] Gestion de masse
    \begin{itemize}
      \setlength\itemsep{0.5em}
      \footnotesize
      \item Renommer 500 photos de \texttt{IMG\_XXXX.jpg} vers \texttt{Vacances\_XXXX.jpg}
    \end{itemize}
  \end{itemize}

\end{frame}

% ---

\begin{frame}{Quand utiliser Bash}

  \begin{itemize}
    \setlength\itemsep{1em}

    \item[\emoji{check-mark-button}] Cas d'usage idéaux
    \begin{itemize}
      \footnotesize
      \setlength\itemsep{0.5em}
      \item automatisation : tâches planifiées, compilation (build), \ldots
      \pause
      \item manipulation de fichiers : renommage de masse, gestion de dossiers, \ldots
      \pause
      \item analyse textuelle simple : extraire des infos de fichiers de logs %(\texttt{grep}, \texttt{sort}, \texttt{uniq})
      \pause
      \item lancer et connecter des programmes (C/Python) sans "wrapper" complexe
    \end{itemize}

    \pause

    \item[\emoji{cross-mark}] Limites
    \begin{itemize}
      \footnotesize
      \setlength\itemsep{0.5em}
      \item données structurées : analyser du JSON, XML, \ldots
      \pause
      \item mathématiques : pas de gestion native des nombres à virgule flottante
      \pause
      \item le code devient illisible si le projet grossit
      \pause
      \item gestion d'erreurs plus difficile qu'avec un langage moderne
    \end{itemize}
  \end{itemize}

\end{frame}

% ---

\begin{frame}{Les variables}

  \begin{terminal}
    \onslide<1->{
    \prompt\ NOM=TOTO \tcomment{pas besoin de guillemets}

    \prompt\ \shcmd{echo} \$TOTO
    }

    \onslide<2->{
    \prompt\ TOTO
    }

    \onslide<3->{
    \prompt\ NOM =TOTO
    }

    \onslide<4->{
    \prompt\ {\color{red}NOM: command not found}
    }

    \onslide<5->{
    \prompt\ NOM= TOTO
    }

    \onslide<6->{
    \prompt\ {\color{red}TOTO: command not found}
    }
  \end{terminal}

  \onslide<7->{
  \begin{itemize}
    \setlength\itemsep{1em}

    \item variables d'environnement : définies par le système
    \begin{itemize}
      \footnotesize
      \setlength\itemsep{0.5em}
      \item \texttt{\$USER} : nom d'utilisateur
      \item \texttt{\$HOME} : chemin vers le dossier personnel
      \item \texttt{\$PWD} : dossier courant
      \item \texttt{\$PATH} : dossiers où rechercher les programmes (\texttt{ls}, \texttt{pwd}, \texttt{mkdir}, \ldots)
    \end{itemize}
  \end{itemize}
  }

\end{frame}

% ---

\begin{frame}[fragile]{Calculs et Arithmétique}

  Par défaut, Bash considère tout comme du texte

  \begin{terminal}
    \onslide<1->{
    \prompt\ x=10

    \prompt\ y=5

    \prompt\ \shcmd{echo} \$x+\$y
    }

    \onslide<2->{
    \prompt\ 10+5
    }

    \onslide<3->{
    \prompt\ \shcmd{echo} \$((x+y)) \tcomment{pas besoin d'utiliser \$x, \$y}

    \prompt\ 15
    }

    \onslide<4->{
    \prompt\ \shcmd{echo} \$((x\%y))
    }

    \onslide<5->{
    \prompt\ 0
    }

    \onslide<6->{
    \prompt\ ((x++)); \shcmd{echo} \$x
    }

    \onslide<7->{
    \prompt\ 11
    }

    \onslide<8->{
    \prompt\ ((x+=1)); \shcmd{echo} \$x

    \prompt\ 12
    }

    \onslide<9->{
    \prompt\ \shcmd{echo} \$((10 / 3))
    }

    \onslide<10->{
    \prompt\ 3
    }
  \end{terminal}

\end{frame}

% ---

\begin{frame}[fragile]{Conditions}

  \begin{terminal}
    \onslide<1->{
    \prompt\ \tcomment{Le fichier "fichier.txt" existe-t-il ?}
    }

    \onslide<2->{
    \prompt\ \shcmd{test} -f "fichier.txt"  \tcomment{Historique}
    }

    \onslide<3->{
    \prompt\ \shcmd{[} -f "fichier.txt" \shcmd{]}  \tcomment{POSIX (Attention aux espaces !)}
    }

    \onslide<4->{
    \prompt\ \shcmd{[[} -f "fichier.txt" \shcmd{]]}  \tcomment{Spécifique Bash (Recommandé)}
    }
  \end{terminal}

  \begin{itemize}
  \setlength\itemsep{0.75em}

    \onslide<5->{
    \item nombres : \texttt{[[ a -eq b ]]}
    \begin{itemize}
      \setlength\itemsep{0.25em}
      \footnotesize
      \item \texttt{-eq} (equal) / \texttt{-ne} (not equal)
      \item \texttt{-lt} (lower than) / \texttt{-le} (lower or equal)
      \item \texttt{-gt} (greater than) / \texttt{-ge} (greater or equal)
    \end{itemize}
    }

    % ---

    \onslide<6->{
    \item texte (chaînes de caractères) : \texttt{[[ a == b ]]}
    \begin{itemize}
      \setlength\itemsep{0.5em}
      \footnotesize
      \item \texttt{==} : identique (préféré à \texttt{=})
      \item \texttt{!=} : différent
    \end{itemize}
    }

    % ---

    \onslide<7->{
    \item[\emoji{warning}]
    code de retour (\texttt{\$?})
    \begin{itemize}
      \setlength\itemsep{0.5em}
      \footnotesize
      \item 0 : succès (Vrai)
      \item 1 (ou plus) : échec (Faux)
    \end{itemize}
    }

  \end{itemize}

\end{frame}

% ---

\begin{frame}[fragile]{Boucle FOR}

\begin{minted}{bash}
for variable in liste
do
  # commandes...
done
\end{minted}

  \pause

  \begin{terminal}
    \onslide<2->{
    \prompt\ \shcmd{for} i \shcmd{in} rouge vert bleu{\color{red};} \shcmd{do} \shcmd{echo} \$i{\color{red};} \shcmd{done}
    }

    \onslide<3->{
    \prompt\ rouge
  
    \prompt\ vert
  
    \prompt\ bleu
    }
  
    \onslide<4->{
    \prompt\ 
  
    \prompt\ \shcmd{for} i \shcmd{in} \{1..3\}; \shcmd{do} \shcmd{echo} \$i; \shcmd{done}
    }
  
    \onslide<5->{
    \prompt\ 1
  
    \prompt\ 2
  
    \prompt\ 3
    }
  \end{terminal}

\end{frame}

% ---

\begin{frame}[fragile]{if / elif / else}

  \begin{minted}{bash}
if [[ condition ]]; then
    # commandes si vrai
elif [[ autre_cond ]]; then
    # sinon si...
else
    # sinon...
fi
  \end{minted}

  \begin{terminal}
    \footnotesize
    \prompt\ \tcomment{condition1 et condition2 :}

    \prompt\ condition1 \&\& condition2

    \prompt\ \tcomment{condition1 ou condition2 :}

    \prompt\ condition1 || condition2

    \prompt\ \tcomment{négation :}

    \prompt\ ! condition
  \end{terminal}

\end{frame}

% ---

\begin{frame}[fragile]{Exemples}

  \begin{terminal}
    \footnotesize
    \prompt\ a=5; b=1

    \prompt\ \shcmd{[[} a > b \shcmd{]]} \&\& \shcmd{echo} "a > b"

    \prompt\

    \prompt\ \shcmd{[[} a < b \shcmd{]]} \&\& \shcmd{echo} "a < b"

    \prompt\ a < b

    \prompt\ \shcmd{[[} a -gt b \shcmd{]]} \&\& \shcmd{echo} "a > b"

    \prompt\ a > b

    \prompt\ ((a > b)) \&\& \shcmd{echo} "a > b"

    \prompt\ a > b
  \end{terminal}

\end{frame}

% ---

\begin{frame}[fragile]{Boucle While}

\begin{minted}{bash}
while [[ condition ]]; do
    # Commandes à répéter
done
\end{minted}

\begin{minted}{bash}
while true; do
    # Commandes à répéter
    if [[ condition_fin ]]; then
        break
    fi
done
\end{minted}

  \begin{itemize}
    \item[\emoji{warning}] Attention aux boucles infinies
  \end{itemize}
\end{frame}

% ---

\begin{frame}[fragile]{Choix multiples (Case)}

  Quand on a beaucoup de conditions à tester sur une seule variable, \texttt{case} 
  est plus propre qu'une suite de \texttt{if / elif / elif}

\begin{minted}{bash}
case $variable in
    motif1)
        commandes ;;
    motif2 | motif3)    # Le tuyau | signifie OU
        commandes ;;
    *)                  # * capte tout le reste (Default)
        commandes_par_defaut ;;
esac
\end{minted}

  \vspace{0.1cm}
  \footnotesize
  \textbf{Attention :} Ne pas oublier le double point-virgule \texttt{;;} à la fin de chaque bloc !
\end{frame}

% ---

\begin{frame}[fragile]{Exemple}

  Gestion d'une réponse utilisateur

\begin{minted}{bash}
read -p "Voulez-vous continuer ? (oui/non) " rep

case $rep in
    # Accepte "o", "O", "oui", "Oui", "OUI"...
    [oO] | [oO][uU][iI])
        echo "C'est parti !" ;;
    [nN]*)
        echo "Arrêt du script."
    *)
        echo "Je n'ai pas compris..." ;;
esac
\end{minted}

\end{frame}

% ---

\begin{frame}[fragile]{Script Bash}

  \begin{itemize}

    \item nommage du fichier :
    \begin{itemize}
      \footnotesize
      \item [\emoji{check-mark-button}] lettres (a-z), chiffres (0-9), tirets (\texttt{-}, \texttt{\_}) et point (\texttt{.})
      \item [\emoji{cross-mark}] espaces et caractères accentués (é, à, \ldots)
      \item extension : \texttt{.sh} : pour aider l'éditeur de texte
    \end{itemize}

    \item fichier \texttt{hello.sh}
\begin{minted}{bash}
# Ceci est un commentaire
echo "Hello World!"
\end{minted}

    \item pour exécuter
    \begin{terminal}
      \prompt\ \shcmd{bash} hello.sh

      \prompt\ Hello World!
    \end{terminal}
  \end{itemize}

\end{frame}

% ---

\begin{frame}[fragile]{Shebang}

  \begin{itemize}

    \item \texttt{Shebang} : indique quel interpréteur utiliser (1\textsuperscript{ère} ligne)
\begin{minted}{bash}
#!/usr/bin/env bash
\end{minted}

    \item alternative (moins portable) : \texttt{\#!/bin/bash}

    \item[\emoji{warning}] chemin obligatoire (sauf si \texttt{PATH} est ajusté)

    \begin{terminal}
      \footnotesize
      \prompt\ \shcmd{./hello.sh}

      \prompt\ bash: ./hello.sh: Permission denied

      \prompt\ \tcomment{changer les permissions}

      \prompt\ \shcmd{chmod} +x hello.sh

      \prompt\ \shcmd{./hello.sh}

      \prompt\ Hello World!
    \end{terminal}
  \end{itemize}

\end{frame}

% ---

\begin{frame}[fragile]{Permissions UNIX}

  \begin{itemize}
    \item chaque fichier/dossier possède des droits d'accès (\texttt{ls -l})
    \begin{center}
      \large
      \texttt{\textcolor{gray}{-} \textcolor{blue}{rwx} \textcolor{orange}{r-x} \textcolor{red}{r--}}
    \end{center}

    \begin{itemize}
      \footnotesize
      \item \textcolor{gray}{-} : fichier régulier
      \item \textcolor{gray}{d} : dossier
      \item \textcolor{gray}{l} : lien symbolique
    \end{itemize}

    \begin{itemize}
      \footnotesize
      \item \textcolor{blue}{\textbf{u} (\texttt{user})} : le propriétaire du fichier
      \item \textcolor{orange}{\textbf{g} (\texttt{group})} : le groupe
      \item \textcolor{red}{\textbf{o} (\texttt{other})} : le reste du monde
    \end{itemize}

    \begin{itemize}
      \footnotesize
      \item \texttt{\textbf{r}} (\textit{read}) : lecture
      \item \texttt{\textbf{w}} (\textit{write}) : écriture
      \item \texttt{\textbf{x}} (\textit{execute}) : exécution
    \end{itemize}

    \item modifier les droits : \texttt{chmod [qui][+/-][quoi] script.sh}
    \begin{terminal}
      \footnotesize
      \prompt\ \shcmd{chmod} u+x hello.sh \tcomment{ajoute x pour le propriétaire}

      \prompt\ \shcmd{chmod} go-w hello.sh \tcomment{enlève w au groupe et aux autres}

      \prompt\ \shcmd{chmod} +x hello.sh \tcomment{ajoute x pour tout le monde}
    \end{terminal}
  \end{itemize}

\end{frame}

% ---

\begin{frame}[fragile]{Arguments du script}

  \begin{terminal}
    \prompt\ \shcmd{./script.sh} arg1 arg2 arg3
  \end{terminal}

  \begin{itemize}
    \item \texttt{\$\#} : nombre total d'arguments

    \item \texttt{\$@} : liste de tous les arguments

    \item \texttt{\$0} : nom du script (avec le chemin)

    \item \texttt{\$1} : premier argument

    \item \texttt{\$2} : deuxième argument

    \item \texttt{\$3} : troisième argument
  \end{itemize}
 
\end{frame}
% ---

\begin{frame}[fragile]{Exemple}

  \begin{itemize}
 
    \item script \texttt{hello.sh}
\begin{minted}{bash}
#!/usr/bin/env bash
echo "Prenom: $0"
echo "Age: $1 ans"
\end{minted}

    \begin{terminal}
      \footnotesize
      \prompt\ \shcmd{./hello.sh} Toto 20

      \prompt\ Prenom: Toto

      \prompt\ Age: 20 ans

      \prompt\ \shcmd{./hello.sh} Jean Christophe 20

      \prompt\ Prenom: Jean

      \prompt\ Age: Christophe ans

      \prompt\ \shcmd{./hello.sh} "Jean Christophe" 20

      \prompt\ Prenom: Jean Christophe

      \prompt\ Age: 20 ans
    \end{terminal}

  \end{itemize}

\end{frame}

% ---

\begin{frame}[fragile]{Fonctions}

  \begin{itemize}

    \item déclaration et appel
    \begin{itemize}
      \footnotesize
      \item on définit la fonction avec des parenthèses vides \texttt{()}
      \item on l'appelle simplement par son nom (sans parenthèses)
    \end{itemize}

\begin{minted}{bash}
# définition
ma_fonction() {
    echo "Hello!"
}

# appel
ma_fonction
\end{minted}

    \item arguments
    \begin{itemize}
      \footnotesize
      \item on passe les valeurs à l'appel : \texttt{ma\_fonction \textcolor{blue}{arg1} \textcolor{orange}{arg2}}
      \item on les récupère dans la fonction avec \texttt{\$1}, \texttt{\$2} \ldots
    \end{itemize}
  \end{itemize}

\end{frame}

% ---

\begin{frame}[fragile]{Fonctions}

  \begin{itemize}

    \item portée des variables dans une fonction
    \begin{itemize}
      \footnotesize
      \item par défaut, toute variable est globale
      \item on utilise ``\texttt{local}'' pour confiner une variable à la fonction
    \end{itemize}

\begin{minted}{bash}
additionner() {
    local resultat=$(($1 + $2))
    echo "La somme est : $resultat"
}

additionner 10 5  # Affiche : La somme est : 15
# echo $resultat  # Erreur car la variable est locale
\end{minted}

  \end{itemize}

\end{frame}

% ---

\begin{frame}{Flux standards (Entrées / Sorties)}

  chaque programme est connecté à 3 "canaux" (File Descriptors)

  \begin{itemize}
    \item 0 : Entrée Standard (stdin)
    \begin{itemize}
      \footnotesize
      \item par défaut : Le clavier
      \item c'est ce que le programme lit
    \end{itemize}

    \item 1 : Sortie Standard (stdout)
    \begin{itemize}
      \footnotesize
      \item par défaut : L'écran (Terminal)
      \item c'est là que le programme envoie ses résultats normaux
    \end{itemize}

    \item 2 : Sortie d'Erreur (stderr)
    \begin{itemize}
      \footnotesize
      \item par défaut : L'écran
      \item c'est là que le programme envoie les messages d'erreur
    \end{itemize}

  \end{itemize}

\end{frame}

% ---

\begin{frame}[fragile]{Rediriger le flux standard}

  \begin{itemize}
    \item on peut détourner le flux vers un fichier
    \begin{itemize}
      \footnotesize
      \item redirection simple (\texttt{>}) : écrase le contenu du fichier (remise à zéro)
      \item redirection double (\texttt{>>}) : ajoute à la fin du fichier (append)
    \end{itemize}

    \begin{terminal}
      \footnotesize
      \prompt\ \shcmd{echo} "Coucou" > liste.txt

      \prompt\ \shcmd{cat} liste.txt

      \prompt\ Coucou

      \prompt\ \shcmd{echo} "Nouveau" > liste.txt

      \prompt\ \shcmd{cat} liste.txt

      \prompt\ Nouveau

      \prompt\ \shcmd{echo} "Fin" >> liste.txt

      \prompt\ \shcmd{cat} liste.txt

      \prompt\ Nouveau

      \prompt\ Fin
    \end{terminal}

  \end{itemize}

\end{frame}

% ---

\begin{frame}[fragile]{Rediriger le flux d'erreur }

  \begin{itemize}
    \item pour les erreurs, il faut ajouter \texttt{2} avant le chevron

    \begin{terminal}
      \footnotesize
      \prompt\ \shcmd{ls} fichier

      \prompt\ ls: cannot access 'fichier': No such file or directory

      \prompt\ \shcmd{ls} fichier > liste.txt

      \prompt\ ls: cannot access 'fichier': No such file or directory

      \prompt\ \shcmd{cat} liste.txt

      \prompt\

      \prompt\ \shcmd{ls} fichier > liste.txt 2>erreurs.txt

      \prompt\ ls: cannot access 'fichier': No such file or directory

      \prompt\ \shcmd{cat} erreurs.txt

      \prompt\ ls: cannot access 'fichier': No such file or directory

      \prompt\ \shcmd{ls} fichier > liste.txt 2>\&1

      \prompt\ ls: cannot access 'fichier': No such file or directory

      \prompt\ \shcmd{cat} liste.txt

      \prompt\ ls: cannot access 'fichier': No such file or directory
    \end{terminal}

  \end{itemize}

\end{frame}

% ---

\begin{frame}[fragile]{Le Pipe (tuyau) \texttt{|}}

  \begin{itemize}
    \item Philosophie UNIX : créer de petits outils qui font une 
          seule chose et les combiner

    \item Le Pipe \texttt{|} prend la sortie standard de la commande de gauche 
          et l'injecte directement comme entrée de la commande de droite \\

          \texttt{\textbf{Commande\_A} \quad \textcolor{blue}{1 (Sortie)} 
          \quad $\xrightarrow{\text{\Large |}}$ \quad 
          \textcolor{blue}{0 (Entrée)} \quad \textbf{Commande\_B}}

    \item Exemple : compter les fichiers \texttt{.txt}
    \begin{terminal}
      \footnotesize
      \prompt\ \shcmd{ls} > tmp1.txt

      \prompt\ \shcmd{grep} '\textbackslash.txt' tmp1.txt > tmp2.txt

      \prompt\ \shcmd{wc} -l tmp2.txt

      \prompt\ \shcmd{rm} tmp1.txt tmp2.txt

      \prompt\ \shcmd{ls} | \shcmd{grep} '\textbackslash.txt' | \shcmd{wc} -l
    \end{terminal}

  \end{itemize}

\end{frame}

% ---

\begin{frame}[fragile]{Résultat d'un programme}

  \begin{itemize}

    \item substitution de commande
    \begin{itemize}
      \footnotesize
      \item syntaxe : \texttt{\$(commande)}
      \item Bash exécute la commande entre parenthèses
      \item il remplace l'expression par la sortie (texte) de cette commande
      \item les \textit{backticks} \texttt{`commande`} sont obsolètes
    \end{itemize}

    \begin{terminal}
    \prompt\ aujourdhui=date

    \prompt\ \shcmd{echo} \$aujourdhui

    \prompt\ date
    
    \prompt\  aujourdhui=\$(date)

    \prompt\ \shcmd{echo} \$aujourdhui

    \prompt\ Thu Jan 29 11:24:20 AM CET 2026
    \end{terminal}

  \end{itemize}

\end{frame}

% ---

