
% ---

\begin{frame}{Langages Compilés vs Langages Interprétés}
  \setbeamercovered{transparent}

  \begin{itemize}
    \setlength\itemsep{1em}

    \item <1-> Langages Compilés
    \begin{itemize}
      \setlength\itemsep{0.5em}
      \footnotesize
      \item <2-> code source traduit en un binaire avant l'exécution
      \item <3-> avantage : performance maximale
      \item <4-> inconvénient : compilation nécessaire à chaque changement
      \item <5-> ex: C, C++, Rust, Fortran, \ldots
    \end{itemize}

    \item <1-> Langages Interprétés / Scripts
    \begin{itemize}
      \setlength\itemsep{0.5em}
      \footnotesize
      \item <2-> le code est lu et exécuté ligne par ligne par un interpréteur
      \item <3-> avantage : développement rapide, pas de compilation
      \item <4-> inconvénient : plus lent à l'exécution
      \item <5-> ex: Bash, Python, Ruby, Perl, \ldots
    \end{itemize}
  \end{itemize}

\end{frame}

% ---

\begin{frame}{Pourquoi écrire des scripts ?}

  \begin{itemize}
    \setlength\itemsep{1em}

    \item[\emoji{robot}] Automatisation : les tâches répétitives sont ennuyeuses et sources d'erreurs
    \begin{itemize}
      \setlength\itemsep{0.5em}
      \footnotesize
      \item sauvegarder dossier \texttt{\color{blue}/Factures} sur un serveur 
            distant tous les soirs avant de quitter le travail
    \end{itemize}

    \pause

    \item[\emoji{link}] "Glu"
    \begin{itemize}
      \setlength\itemsep{0.5em}
      \footnotesize
      \item lancer un calcul en C $\rightarrow$
            récupérer le résultat $\rightarrow$
            générer un graphique avec Python
    \end{itemize}

    \pause

    \item[\emoji{file-folder}] Gestion de masse
    \begin{itemize}
      \setlength\itemsep{0.5em}
      \footnotesize
      \item Renommer 500 photos de \texttt{IMG\_XXXX.jpg} vers \texttt{Vacances\_XXXX.jpg}
    \end{itemize}
  \end{itemize}

\end{frame}

% ---

\begin{frame}{Quand utiliser Bash}

  \begin{itemize}
    \setlength\itemsep{1em}

    \item[\emoji{check-mark-button}] Cas d'usage idéaux
    \begin{itemize}
      \footnotesize
      \setlength\itemsep{0.5em}
      \item automatisation : tâches planifiées, compilation (build), \ldots
      \pause
      \item manipulation de fichiers : renommage de masse, gestion de dossiers, \ldots
      \pause
      \item analyse textuelle simple : extraire des infos de fichiers de logs %(\texttt{grep}, \texttt{sort}, \texttt{uniq})
      \pause
      \item lancer et connecter des programmes (C/Python) sans "wrapper" complexe
    \end{itemize}

    \pause

    \item[\emoji{cross-mark}] Limites
    \begin{itemize}
      \footnotesize
      \setlength\itemsep{0.5em}
      \item données structurées : analyser du JSON, XML, \ldots
      \pause
      \item mathématiques : pas de gestion native des nombres à virgule flottante
      \pause
      \item le code devient illisible si le projet grossit
      \pause
      \item gestion d'erreurs plus difficile qu'avec un langage moderne
    \end{itemize}
  \end{itemize}

\end{frame}

% ---

\begin{frame}{Les variables}

  \begin{terminal}
    \onslide<1->{
    \prompt\ NOM=TOTO \tcomment{pas besoin de guillemets}

    \prompt\ \shcmd{echo} \$TOTO
    }

    \onslide<2->{
    \prompt\ TOTO
    }

    \onslide<3->{
    \prompt\ NOM =TOTO
    }

    \onslide<4->{
    \prompt\ {\color{red}NOM: command not found}
    }

    \onslide<5->{
    \prompt\ NOM= TOTO
    }

    \onslide<6->{
    \prompt\ {\color{red}TOTO: command not found}
    }
  \end{terminal}

  \onslide<7->{
  \begin{itemize}
    \setlength\itemsep{1em}

    \item variables d'environnement : définies par le système
    \begin{itemize}
      \footnotesize
      \setlength\itemsep{0.5em}
      \item \texttt{\$USER} : nom d'utilisateur
      \item \texttt{\$HOME} : chemin vers le dossier personnel
      \item \texttt{\$PWD} : dossier courant
      \item \texttt{\$PATH} : dossiers où rechercher les programmes (\texttt{ls}, \texttt{pwd}, \texttt{mkdir}, \ldots)
    \end{itemize}
  \end{itemize}
  }

\end{frame}

% ---

\begin{frame}[fragile]{Calculs et Arithmétique}

  Par défaut, Bash considère tout comme du texte

  \begin{terminal}
    \onslide<1->{
    \prompt\ x=10

    \prompt\ y=5

    \prompt\ \shcmd{echo} \$x+\$y
    }

    \onslide<2->{
    \prompt\ 10+5
    }

    \onslide<3->{
    \prompt\ \shcmd{echo} \$((x+y)) \tcomment{pas besoin d'utiliser \$x, \$y}

    \prompt\ 15
    }

    \onslide<4->{
    \prompt\ \shcmd{echo} \$((x\%y))
    }

    \onslide<5->{
    \prompt\ 0
    }

    \onslide<6->{
    \prompt\ ((x++)); \shcmd{echo} \$x
    }

    \onslide<7->{
    \prompt\ 11
    }

    \onslide<8->{
    \prompt\ ((x+=1)); \shcmd{echo} \$x

    \prompt\ 12
    }

    \onslide<9->{
    \prompt\ \shcmd{echo} \$((10 / 3))
    }

    \onslide<10->{
    \prompt\ 3
    }
  \end{terminal}

\end{frame}

% ---

\begin{frame}[fragile]{Évaluer des conditions}

  Il existe 3 manières d'écrire un test

  \begin{terminal}
    \onslide<1->{
    \prompt\ \tcomment{Le fichier "fichier.txt" existe-t-il ?}
    }

    \onslide<2->{
    \prompt\

    \prompt\ \shcmd{test} -f "fichier.txt"  \tcomment{Historique}
    }

    \onslide<3->{
    \prompt\

    \prompt\ \shcmd{[} -f "fichier.txt" \shcmd{]}  \tcomment{POSIX (Attention aux espaces !)}
    }

    \onslide<4->{
    \prompt\

    \prompt\ \shcmd{[[} -f "fichier.txt" \shcmd{]]}  \tcomment{Spécifique Bash (Recommandé)}
    }
  \end{terminal}

  \onslide<5->{
  \begin{itemize}
  \setlength\itemsep{1em}

    \item[\emoji{warning}]
    contrairement à l'algèbre booléenne, Bash raisonne en "code de retour" (\texttt{\$?})
    \begin{itemize}
      \setlength\itemsep{0.5em}
      \footnotesize
      \item 0 signifie succès (Vrai)
      \item 1 (ou plus) signifie échec (Faux)
    \end{itemize}
  \end{itemize}
  }

\end{frame}

% ---

\begin{frame}[fragile]{Les Opérateurs de Comparaison}

  \begin{itemize}
  \setlength\itemsep{1em}

    \item nombres
    \begin{itemize}
      \setlength\itemsep{0.5em}
      \footnotesize
      \item \texttt{-eq} (equal) / \texttt{-ne} (not equal)
      \item \texttt{-lt} (lower than) / \texttt{-le} (lower or equal)
      \item \texttt{-gt} (greater than) / \texttt{-ge} (greater or equal)
    \end{itemize}

    \pause

    \item texte (chaînes de caractères)
    \begin{itemize}
      \setlength\itemsep{0.5em}
      \footnotesize
      \item \texttt{==} : identique (préféré à \texttt{=})
      \item \texttt{!=} : différent
    \end{itemize}

    \pause

    \item fichiers
    \begin{itemize}
      \setlength\itemsep{0.5em}
      \footnotesize
      \item \texttt{-f fichier} : le fichier existe 
      \item \texttt{-d dossier} : le dossier existe
    \end{itemize}
  \end{itemize}

\end{frame}

% ---

\begin{frame}[fragile]{Boucle FOR}

\begin{minted}{bash}
for variable in liste
do
  # commandes...
done
\end{minted}

  Exemples :

  \pause

  \begin{terminal}
    \onslide<2->{
    \prompt\ \shcmd{for} i \shcmd{in} rouge vert bleu{\color{red};} \shcmd{do} \shcmd{echo} \$i{\color{red};} \shcmd{done}
    }

    \onslide<3->{
    \prompt\ rouge
  
    \prompt\ vert
  
    \prompt\ bleu
    }
  
    \onslide<4->{
    \prompt\ 
  
    \prompt\ \shcmd{for} i \shcmd{in} \{1..3\}; \shcmd{do} \shcmd{echo} \$i; \shcmd{done}
    }
  
    \onslide<5->{
    \prompt\ 1
  
    \prompt\ 2
  
    \prompt\ 3
    }
  \end{terminal}

\end{frame}

% ---

\begin{frame}[fragile]{Conditions (If / Else)}

\begin{minted}{bash}
if [[ condition ]]; then
    # commandes si vrai
elif [[ autre_cond ]]; then
    # sinon si...
else
    # sinon...
fi
\end{minted}

\end{frame}

% ---

\begin{frame}[fragile]{Boucle WHILE}

\begin{minted}{bash}
while [[ condition ]]; do
    # Commandes à répéter
done
\end{minted}

  \begin{itemize}
    \item[\emoji{warning}] Attention aux boucles infinies
  \end{itemize}
\end{frame}

% ---





%\begin{frame}{Structure d'un script Bash}
%
%  Un script Bash est un simple fichier texte. Par convention, on lui donne l'extension \texttt{.sh}.
%
%  \vspace{0.3cm}
%  \begin{exampleblock}{Exemple : \texttt{bonjour.sh}}
%    \texttt{\#!/bin/bash} \\
%    \texttt{\# Ceci est un commentaire} \\
%    \texttt{echo "Bonjour tout le monde !"}
%  \end{exampleblock}
%
%  \vspace{0.3cm}
%  \begin{itemize}
%    \item \textbf{Le Shebang (\texttt{\#!})} :
%    \begin{itemize}
%        \footnotesize
%        \item C'est obligatoirement la 1\textsuperscript{ère} ligne.
%        \item \texttt{\#!/bin/bash} indique au système : "Utilise le programme \textit{bash} situé dans \textit{/bin} pour exécuter ce fichier".
%    \end{itemize}
%    \item \textbf{\texttt{echo}} : Commande pour afficher du texte à l'écran.
%    \item \textbf{\texttt{\#}} : Tout ce qui suit est ignoré (commentaire).
%  \end{itemize}
%\end{frame}

% ---

%\begin{frame}{Rendre le script exécutable}
%  Par défaut, pour des raisons de sécurité, un fichier texte n'est pas exécutable.
%
%  \begin{alertblock}{Le piège du débutant}
%    Si vous tapez juste \texttt{./bonjour.sh}, vous aurez l'erreur : \\
%    \texttt{Permission denied (Permission non accordée)}
%  \end{alertblock}
%
%  \vspace{0.3cm}
%  \textbf{La solution : changer les droits (permissions)}
%
%  \begin{enumerate}
%    \item Rendre exécutable (une seule fois) :
%    \par\centering\fbox{\texttt{chmod +x bonjour.sh}}
%
%    \item Exécuter le script :
%    \par\centering\fbox{\texttt{./bonjour.sh}}
%  \end{enumerate}
%
%  \vspace{0.2cm}
%  \footnotesize
%  \textit{Note : Le \texttt{./} signifie "dans le dossier courant". Sans cela, le shell cherche la commande dans les dossiers système.}
%\end{frame}

% ---

%\begin{frame}{Les Arguments du script}
%  On veut souvent passer des informations au script dès son lancement, sans modifier le code.
%  \vspace{0.2cm}
%
%  \textbf{Commande :} \texttt{./salut.sh \textcolor{blue}{Pierre} \textcolor{orange}{Paul}}
%
%  \vspace{0.3cm}
%  Bash stocke ces mots automatiquement dans des variables numérotées :
%
%  \begin{itemize}
%    \setlength\itemsep{1em}
%    \item \texttt{\$0} : Le nom du script (\texttt{./salut.sh})
%    \item \texttt{\textcolor{blue}{\$1}} : Le premier argument (\texttt{Pierre})
%    \item \texttt{\textcolor{orange}{\$2}} : Le deuxième argument (\texttt{Paul})
%    \item \texttt{\$\#} : Le nombre total d'arguments (ici \texttt{2})
%    \item \texttt{\$@} : La liste de tous les arguments
%  \end{itemize}
%
%  \vspace{0.3cm}
%  \begin{exampleblock}{Exemple pratique}
%    \texttt{echo "Bonjour \$1, comment va \$2 ?"} \\
%    $\rightarrow$ Affiche : Bonjour Pierre, comment va Paul ?
%  \end{exampleblock}
%\end{frame}

% ---

%\begin{frame}[fragile]{L'interaction utilisateur (read)}
%
%  Pour demander une information à l'utilisateur pendant l'exécution, on utilise la commande \texttt{read}.
%
%  \vspace{0.5cm}
%  \begin{block}{Syntaxe}
%    \texttt{read -p "Message à afficher : " nom\_variable}
%  \end{block}
%
%  \vspace{0.3cm}
%  \textbf{Exemple de script interactif :}
%  \begin{exampleblock}{}
%\begin{minted}{bash}
%#!/bin/bash
%
%read -p "Quel est votre nom ? " user_name
%echo "Bienvenue, $user_name !"
%
%read -p "Voulez-vous continuer ? (o/n) " reponse
%if [ "$reponse" = "o" ]; then
%    echo "On continue..."
%fi
%\end{minted}
%  \end{exampleblock}
%\end{frame}

% ---

%\begin{frame}{Bonnes pratiques de scripting}
%  Pour écrire des scripts robustes et lisibles (et avoir une bonne note !) :
%
%  \vspace{0.3cm}
%  \begin{enumerate}
%    \setlength\itemsep{1em}
%    \item \textbf{Toujours le Shebang} :
%    La 1\textsuperscript{ère} ligne doit être \texttt{\#!/bin/bash}.
%
%    \item \textbf{Indentation} :
%    Décalez le code à l'intérieur des \texttt{if} et des \texttt{for} (comme en Python ou C).
%
%    \item \textbf{Guillemets} :
%    Protégez vos variables avec des guillemets doubles si elles peuvent contenir des espaces.
%    \\ \texttt{rm "\$nom\_fichier"} (au cas où le fichier s'appelle "TP 1.txt").
%
%    \item \textbf{Noms parlants} :
%    \texttt{\$cpt} est mieux que \texttt{\$x}, mais \texttt{\$compteur} est idéal.
%
%    \item \textbf{Commentaires} :
%    Utilisez \texttt{\#} pour expliquer les parties complexes.
%  \end{enumerate}
%\end{frame}

% ---

%\begin{frame}{Redirections et Pipes (Tuyaux)}
%  En UNIX, la philosophie est de créer de petits outils qui font une seule chose, et de les connecter entre eux.
%
%  \vspace{0.2cm}
%  \textbf{1. Les Redirections vers des fichiers :}
%  \begin{itemize}
%    \item \texttt{\textbf{>}} : Redirige la sortie (écrase le fichier).
%    \item \texttt{\textbf{>>}} : Redirige la sortie (ajoute à la fin du fichier).
%    \item \textit{Exemple :} \texttt{echo "Log fini" >> rapport.txt}
%  \end{itemize}
%
%  \vspace{0.3cm}
%  \textbf{2. Le Pipe (Le tuyau \texttt{|}) :}
%  \begin{itemize}
%    \item Connecte la sortie d'une commande à l'entrée de la suivante.
%    \item C'est de la plomberie logicielle !
%  \end{itemize}
%
%  \begin{exampleblock}{Exemple puissant}
%    \texttt{ls -l | grep ".txt" | wc -l}
%    \begin{enumerate}
%        \footnotesize
%        \item \texttt{ls -l} : Liste tout le contenu.
%        \item \texttt{grep ".txt"} : Ne garde que les lignes contenant ".txt".
%        \item \texttt{wc -l} : Compte le nombre de lignes restantes.
%    \end{enumerate}
%    $\rightarrow$ \textbf{Résultat :} Affiche le nombre de fichiers texte.
%  \end{exampleblock}
%\end{frame}

% ---

%\begin{frame}{Le Globbing (Jokers de fichiers)}
%  Le \textbf{Globbing} est un mécanisme du Shell pour sélectionner rapidement des fichiers par leurs noms.
%
%  \begin{alertblock}{Important}
%    C'est le Shell qui "développe" (remplace) le joker par la liste des fichiers correspondants \textbf{avant} de lancer la commande.
%  \end{alertblock}
%
%  \vspace{0.2cm}
%  \textbf{Les motifs principaux :}
%  \begin{itemize}
%    \item \texttt{\textbf{*}} : Remplace n'importe quelle chaîne (vide ou longue).
%    \item \texttt{\textbf{?}} : Remplace exactement \textbf{un} caractère.
%    \item \texttt{\textbf{[abc]}} : Remplace un seul caractère parmi la liste (a, b ou c).
%  \end{itemize}
%
%  \vspace{0.3cm}
%  \begin{exampleblock}{Exemples}
%    \begin{itemize}
%        \item \texttt{ls *.txt} $\rightarrow$ Liste tous les fichiers finissant par .txt
%        \item \texttt{rm TP?.c} $\rightarrow$ Supprime \texttt{TP1.c}, \texttt{TP2.c}, mais PAS \texttt{TP10.c}
%    \end{itemize}
%  \end{exampleblock}
%\end{frame}

% ---

%\begin{frame}{Les Expressions Régulières (Regex)}
%  Une Regex est un motif pour décrire une chaîne de caractères. Elle est utilisée par des outils comme \texttt{grep} pour chercher \textbf{dans le contenu} des fichiers.
%
%  \vspace{0.2cm}
%  \textbf{Les métacaractères de base :}
%  \begin{itemize}
%    \item \texttt{\textbf{\textasciicircum}} (accent circonflexe) : Début de ligne.
%    \item \texttt{\textbf{\$}} : Fin de ligne.
%    \item \texttt{\textbf{.}} (point) : N'importe quel caractère unique.
%    \item \texttt{\textbf{*}} : Répétition (0 ou plusieurs fois) du caractère \textit{précédent}.
%  \end{itemize}
%
%  \vspace{0.3cm}
%  \begin{exampleblock}{Exemples avec grep}
%    \texttt{grep "\textasciicircum int" main.c} \\
%    $\rightarrow$ Trouve les lignes qui \textbf{commencent} par "int".
%
%    \texttt{grep "error\$" log.txt} \\
%    $\rightarrow$ Trouve les lignes qui \textbf{finissent} par "error".
%  \end{exampleblock}
%\end{frame}

% ---

%\begin{frame}{Attention à la confusion !}
%  Le même symbole n'a pas le même sens selon le contexte !
%
%  \vspace{0.2cm}
%  \renewcommand{\arraystretch}{1.4}
%  \begin{table}
%    \centering
%    \begin{tabular}{|c|l|l|}
%      \hline
%      \rowcolor{gray!20}
%      \textbf{Symbole} & \textbf{En Globbing (Fichiers)} & \textbf{En Regex (Texte/Grep)} \\
%      \hline
%      \textbf{\texttt{*}} & N'importe quoi & Répétition du précédent \\
%      \hline
%      \textbf{\texttt{.}} & Un vrai point (littéral) & N'importe quel caractère \\
%      \hline
%      \textbf{\texttt{?}} & Un seul caractère & 0 ou 1 fois le précédent (optionnel) \\
%      \hline
%    \end{tabular}
%  \end{table}
%
%  \vspace{0.3cm}
%  \textbf{Basique vs Étendue (Extended Regex) :}
%  \begin{itemize}
%    \item Par défaut, \texttt{grep} utilise les regex basiques (vieux standard).
%    \item Pour utiliser des symboles modernes comme \texttt{+} (au moins 1 fois), \texttt{?} (0 ou 1 fois) ou \texttt{|} (OU logique), il faut utiliser :
%    \par\centering\fbox{\texttt{grep -E} \quad ou \quad \texttt{egrep}}
%  \end{itemize}
%\end{frame}

% ---

