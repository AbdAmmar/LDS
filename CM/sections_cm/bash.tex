
% ---

\begin{frame}{Langages Compilés vs Langages Interprétés}
  \setbeamercovered{transparent}

  \begin{itemize}
    \setlength\itemsep{1em}

    \item <1-> Langages Compilés
    \begin{itemize}
      \setlength\itemsep{0.5em}
      \footnotesize
      \item <2-> code source traduit en un binaire avant l'exécution
      \item <3-> avantage : performance maximale
      \item <4-> inconvénient : compilation nécessaire à chaque changement
      \item <5-> ex: C, C++, Rust, Fortran, \ldots
    \end{itemize}

    \item <1-> Langages Interprétés / Scripts
    \begin{itemize}
      \setlength\itemsep{0.5em}
      \footnotesize
      \item <2-> le code est lu et exécuté ligne par ligne par un interpréteur
      \item <3-> avantage : développement rapide, pas de compilation
      \item <4-> inconvénient : plus lent à l'exécution
      \item <5-> ex: Bash, Python, Ruby, Perl, \ldots
    \end{itemize}
  \end{itemize}

\end{frame}

% ---

\begin{frame}{Pourquoi écrire des scripts ?}

  \begin{itemize}
    \setlength\itemsep{1em}

    \item[\emoji{robot}] Automatisation : les tâches répétitives sont ennuyeuses et sources d'erreurs
    \begin{itemize}
      \setlength\itemsep{0.5em}
      \footnotesize
      \item sauvegarder dossier \texttt{\color{blue}/Factures} sur un serveur 
            distant tous les soirs avant de quitter le travail
    \end{itemize}

    \pause

    \item[\emoji{link}] "Glu"
    \begin{itemize}
      \setlength\itemsep{0.5em}
      \footnotesize
      \item lancer un calcul en C $\rightarrow$
            récupérer le résultat $\rightarrow$
            générer un graphique avec Python
    \end{itemize}

    \pause

    \item[\emoji{file-folder}] Gestion de masse
    \begin{itemize}
      \setlength\itemsep{0.5em}
      \footnotesize
      \item Renommer 500 photos de \texttt{IMG\_XXXX.jpg} vers \texttt{Vacances\_XXXX.jpg}
    \end{itemize}
  \end{itemize}

\end{frame}

% ---

\begin{frame}{Quand utiliser Bash}

  \begin{itemize}
    \setlength\itemsep{1em}

    \item[\emoji{check-mark-button}] Cas d'usage idéaux
    \begin{itemize}
      \footnotesize
      \setlength\itemsep{0.5em}
      \item automatisation : tâches planifiées, compilation (build), \ldots
      \pause
      \item manipulation de fichiers : renommage de masse, gestion de dossiers, \ldots
      \pause
      \item analyse textuelle simple : extraire des infos de fichiers de logs %(\texttt{grep}, \texttt{sort}, \texttt{uniq})
      \pause
      \item lancer et connecter des programmes (C/Python) sans "wrapper" complexe
    \end{itemize}

    \pause

    \item[\emoji{cross-mark}] Limites
    \begin{itemize}
      \footnotesize
      \setlength\itemsep{0.5em}
      \item données structurées : analyser du JSON, XML, \ldots
      \pause
      \item mathématiques : pas de gestion native des nombres à virgule flottante
      \pause
      \item le code devient illisible si le projet grossit
      \pause
      \item gestion d'erreurs plus difficile qu'avec un langage moderne
    \end{itemize}
  \end{itemize}

\end{frame}

% ---

\begin{frame}{Les variables}

  \begin{terminal}
    \onslide<1->{
    \prompt\ NOM=TOTO \tcomment{pas besoin de guillemets}

    \prompt\ \shcmd{echo} \$TOTO
    }

    \onslide<2->{
    \prompt\ TOTO
    }

    \onslide<3->{
    \prompt\ NOM =TOTO
    }

    \onslide<4->{
    \prompt\ {\color{red}NOM: command not found}
    }

    \onslide<5->{
    \prompt\ NOM= TOTO
    }

    \onslide<6->{
    \prompt\ {\color{red}TOTO: command not found}
    }
  \end{terminal}

  \onslide<7->{
  \begin{itemize}
    \setlength\itemsep{1em}

    \item variables d'environnement : définies par le système
    \begin{itemize}
      \footnotesize
      \setlength\itemsep{0.5em}
      \item \texttt{\$USER} : nom d'utilisateur
      \item \texttt{\$HOME} : chemin vers le dossier personnel
      \item \texttt{\$PWD} : dossier courant
      \item \texttt{\$PATH} : dossiers où rechercher les programmes (\texttt{ls}, \texttt{pwd}, \texttt{mkdir}, \ldots)
    \end{itemize}
  \end{itemize}
  }

\end{frame}

% ---

\begin{frame}[fragile]{Calculs et Arithmétique}

  Par défaut, Bash considère tout comme du texte

  \begin{terminal}
    \onslide<1->{
    \prompt\ x=10

    \prompt\ y=5

    \prompt\ \shcmd{echo} \$x+\$y
    }

    \onslide<2->{
    \prompt\ 10+5
    }

    \onslide<3->{
    \prompt\ \shcmd{echo} \$((x+y)) \tcomment{pas besoin d'utiliser \$x, \$y}

    \prompt\ 15
    }

    \onslide<4->{
    \prompt\ \shcmd{echo} \$((x\%y))
    }

    \onslide<5->{
    \prompt\ 0
    }

    \onslide<6->{
    \prompt\ ((x++)); \shcmd{echo} \$x
    }

    \onslide<7->{
    \prompt\ 11
    }

    \onslide<8->{
    \prompt\ ((x+=1)); \shcmd{echo} \$x

    \prompt\ 12
    }

    \onslide<9->{
    \prompt\ \shcmd{echo} \$((10 / 3))
    }

    \onslide<10->{
    \prompt\ 3
    }
  \end{terminal}

\end{frame}

% ---

\begin{frame}[fragile]{Conditions}

  \begin{terminal}
    \onslide<1->{
    \prompt\ \tcomment{Le fichier "fichier.txt" existe-t-il ?}
    }

    \onslide<2->{
    \prompt\ \shcmd{test} -f "fichier.txt"  \tcomment{Historique}
    }

    \onslide<3->{
    \prompt\ \shcmd{[} -f "fichier.txt" \shcmd{]}  \tcomment{POSIX (Attention aux espaces !)}
    }

    \onslide<4->{
    \prompt\ \shcmd{[[} -f "fichier.txt" \shcmd{]]}  \tcomment{Spécifique Bash (Recommandé)}
    }
  \end{terminal}

  \begin{itemize}
  \setlength\itemsep{0.75em}

    \onslide<5->{
    \item nombres : \texttt{[[ a -eq b ]]}
    \begin{itemize}
      \setlength\itemsep{0.25em}
      \footnotesize
      \item \texttt{-eq} (equal) / \texttt{-ne} (not equal)
      \item \texttt{-lt} (lower than) / \texttt{-le} (lower or equal)
      \item \texttt{-gt} (greater than) / \texttt{-ge} (greater or equal)
    \end{itemize}
    }

    % ---

    \onslide<6->{
    \item texte (chaînes de caractères) : \texttt{[[ a == b ]]}
    \begin{itemize}
      \setlength\itemsep{0.5em}
      \footnotesize
      \item \texttt{==} : identique (préféré à \texttt{=})
      \item \texttt{!=} : différent
    \end{itemize}
    }

    % ---

    \onslide<7->{
    \item[\emoji{warning}]
    code de retour (\texttt{\$?})
    \begin{itemize}
      \setlength\itemsep{0.5em}
      \footnotesize
      \item 0 : succès (Vrai)
      \item 1 (ou plus) : échec (Faux)
    \end{itemize}
    }

  \end{itemize}

\end{frame}

% ---

\begin{frame}[fragile]{Boucle FOR}

\begin{minted}{bash}
for variable in liste
do
  # commandes...
done
\end{minted}

  \pause

  \begin{terminal}
    \onslide<2->{
    \prompt\ \shcmd{for} i \shcmd{in} rouge vert bleu{\color{red};} \shcmd{do} \shcmd{echo} \$i{\color{red};} \shcmd{done}
    }

    \onslide<3->{
    \prompt\ rouge
  
    \prompt\ vert
  
    \prompt\ bleu
    }
  
    \onslide<4->{
    \prompt\ 
  
    \prompt\ \shcmd{for} i \shcmd{in} \{1..3\}; \shcmd{do} \shcmd{echo} \$i; \shcmd{done}
    }
  
    \onslide<5->{
    \prompt\ 1
  
    \prompt\ 2
  
    \prompt\ 3
    }
  \end{terminal}

\end{frame}

% ---

\begin{frame}[fragile]{if / elif / else}

  \begin{minted}{bash}
if [[ condition ]]; then
    # commandes si vrai
elif [[ autre_cond ]]; then
    # sinon si...
else
    # sinon...
fi
  \end{minted}

  \begin{terminal}
    \footnotesize
    \prompt\ \tcomment{condition1 et condition2 :}

    \prompt\ condition1 \&\& condition2

    \prompt\ \tcomment{condition1 ou condition2 :}

    \prompt\ condition1 || condition2

    \prompt\ \tcomment{négation :}

    \prompt\ ! condition
  \end{terminal}

\end{frame}

% ---

\begin{frame}[fragile]{Exemples}

  \begin{terminal}
    \footnotesize
    \prompt\ a=5; b=1

    \prompt\ \shcmd{[[} a > b \shcmd{]]} \&\& \shcmd{echo} "a > b"

    \prompt\

    \prompt\ \shcmd{[[} a < b \shcmd{]]} \&\& \shcmd{echo} "a < b"

    \prompt\ a < b

    \prompt\ \shcmd{[[} a -gt b \shcmd{]]} \&\& \shcmd{echo} "a > b"

    \prompt\ a > b

    \prompt\ ((a > b)) \&\& \shcmd{echo} "a > b"

    \prompt\ a > b
  \end{terminal}

\end{frame}

% ---

\begin{frame}[fragile]{Boucle While}

\begin{minted}{bash}
while [[ condition ]]; do
    # Commandes à répéter
done
\end{minted}

\begin{minted}{bash}
while true; do
    # Commandes à répéter
    if [[ condition_fin ]]; then
        break
    fi
done
\end{minted}

  \begin{itemize}
    \item[\emoji{warning}] Attention aux boucles infinies
  \end{itemize}
\end{frame}

% ---

\begin{frame}[fragile]{Les Choix Multiples (Case)}
  Quand on a beaucoup de conditions à tester sur une seule variable, \texttt{case} 
  est plus propre qu'une suite de \texttt{if / elif / elif}.

  \begin{block}{Syntaxe Générale}
\begin{minted}{bash}
case $variable in
    motif1)
        commandes ;;
    motif2 | motif3)    # Le tuyau | signifie OU
        commandes ;;
    *)                  # * capte tout le reste (Default)
        commandes_par_defaut ;;
esac
\end{minted}
  \end{block}

  \vspace{0.1cm}
  \footnotesize
  \textbf{Attention :} Ne pas oublier le double point-virgule \texttt{;;} à la fin de chaque bloc !
\end{frame}

% ---

\begin{frame}[fragile]{Exemple}

  \begin{exampleblock}{Exemple : Gestion d'une réponse utilisateur}
\begin{minted}{bash}
read -p "Voulez-vous continuer ? (oui/non) " rep

case $rep in
    # Accepte "o", "O", "oui", "Oui", "OUI"...
    [oO] | [oO][uU][iI])
        echo "C'est parti !" ;;
    [nN]*)
        echo "Arrêt du script."
    *)
        echo "Je n'ai pas compris..." ;;
esac
\end{minted}
  \end{exampleblock}

\end{frame}

% ---

\begin{frame}[fragile]{Script Bash}

  \begin{itemize}

    \item Nommage du fichier :
    \begin{itemize}
      \footnotesize
      \item [\emoji{check-mark-button}] Lettres (a-z), chiffres (0-9), tirets (\texttt{-}, \texttt{\_}) et point (\texttt{.})
      \item [\emoji{cross-mark}] Espaces et caractères accentués (é, à, \ldots)
      \item Extension : \texttt{.sh} : pour aider l'éditeur de texte
    \end{itemize}

    \item fichier \texttt{hello.sh}
\begin{minted}{bash}
# Ceci est un commentaire
echo "Hello World!"
\end{minted}

    pour lancer
    \begin{terminal}
      \prompt\ \shcmd{bash} hello.sh

      \prompt\ Hello World!
    \end{terminal}
  \end{itemize}

\end{frame}

% ---

\begin{frame}[fragile]{Script Bash}

  \begin{itemize}

    \item Shebang  (1\textsuperscript{ère} ligne) : indique quel interpréteur utiliser
\begin{minted}{bash}
#!/usr/bin/env bash
echo "Hello World!"
\end{minted}

    \item alternative (moins portable)
\begin{minted}{bash}
#!/bin/bash
\end{minted}

    \begin{terminal}
      \prompt\ \shcmd{./hello.sh}

      \prompt\ bash: ./hello.sh: Permission denied

      \prompt\ \tcomment{changer les permissions}

      \prompt\ \shcmd{chmod} +x hello.sh

      \prompt\ \shcmd{./hello.sh}

      \prompt\ Hello World!
    \end{terminal}
  \end{itemize}

\end{frame}

% ---

\begin{frame}[fragile]{Arguments du script}

  \begin{itemize}
    \item \texttt{\$0} : Le nom du script (avec le chemin)

    \item \texttt{\$1} : Le premier argument

    \item \texttt{\$2} : Le deuxième argument

    \item \texttt{\$\#} : Le nombre total d'arguments

    \item \texttt{\$@} : La liste de tous les arguments
  \end{itemize}
 
\end{frame}
% ---

\begin{frame}[fragile]{Exemple}

  \begin{itemize}
 
    \item script \texttt{hello.sh}
\begin{minted}{bash}
#!/usr/bin/env bash
echo "Prenom: $0"
echo "Age: $1 ans"
\end{minted}

    \begin{terminal}
      \footnotesize
      \prompt\ \shcmd{./hello.sh} Toto 20

      \prompt\ Prenom: Toto

      \prompt\ Age: 20 ans

      \prompt\ \shcmd{./hello.sh} Jean Christophe 20

      \prompt\ Prenom: Jean

      \prompt\ Age: Christophe ans

      \prompt\ \shcmd{./hello.sh} "Jean Christophe" 20

      \prompt\ Prenom: Jean Christophe

      \prompt\ Age: 20 ans
    \end{terminal}

  \end{itemize}

\end{frame}

% ---

\begin{frame}[fragile]{Les Fonctions : Structurer le code}
  Comme en C ou Python, les fonctions permettent de regrouper des commandes pour éviter les répétitions.
  \par \textit{Imaginez-les comme des "mini-scripts" à l'intérieur du script.}

  \vspace{0.2cm}
  \begin{block}{Déclaration et Appel}
    \begin{itemize}
        \item On définit la fonction avec des parenthèses vides \texttt{()}.
        \item On l'appelle simplement par son nom (sans parenthèses !).
    \end{itemize}
  \end{block}

  \begin{exampleblock}{Exemple simple}
\begin{minted}{bash}
# 1. Définition
dire_bonjour() {
    echo "--------------------"
    echo "Bienvenue utilisateur"
    echo "--------------------"
}

# 2. Appel (plus loin dans le code)
dire_bonjour
\end{minted}
  \end{exampleblock}
\end{frame}

% ---

\begin{frame}[fragile]{Arguments et Portée des variables}
  Les fonctions Bash fonctionnent différemment du C ou de Python sur deux points majeurs.

  \vspace{0.2cm}
  \begin{columns}[t]
    \column{0.5\textwidth}
    \begin{block}{1. Les Arguments}
      Pas d'arguments entre parenthèses !
      \begin{itemize}
        \item On passe les valeurs à l'appel : \\ \texttt{ma\_fonc \textcolor{blue}{arg1} \textcolor{orange}{arg2}}
        \item On les récupère \textbf{dans} la fonction avec \texttt{\$1}, \texttt{\$2}...
      \end{itemize}
    \end{block}

    \column{0.5\textwidth}
    \begin{block}{2. Variables Locales}
      Par défaut, toute variable est \textbf{globale} (visible partout).
      \begin{itemize}
        \item Utilisez le mot-clé \texttt{\textbf{local}} pour confiner une variable à la fonction.
      \end{itemize}
    \end{block}
  \end{columns}

  \vspace{0.3cm}
  \begin{exampleblock}{Exemple complet}
\begin{minted}{bash}
additionner() {
    # $1 et $2 sont les arguments passés à la fonction
    local resultat=$(( $1 + $2 ))
    echo "La somme est : $resultat"
}

additionner 10 5  # Affiche : La somme est : 15
# echo $resultat  # Erreur car la variable est locale
\end{minted}
  \end{exampleblock}
\end{frame}

% ---

\begin{frame}[fragile]{Résultat d'une commande}

  Souvent, on ne veut pas afficher le résultat d'une commande à l'écran, 
  mais le \textbf{stocker} dans une variable pour l'utiliser plus tard.

  \vspace{0.2cm}
  \begin{block}{La Substitution de Commande}
    Syntaxe : \texttt{\textbf{\$(commande)}}
    \begin{itemize}
        \item Bash exécute la commande entre parenthèses.
        \item Il remplace l'expression par la sortie (texte) de cette commande.
    \end{itemize}
  \end{block}

  \vspace{0.3cm}
  \begin{exampleblock}{Comparaison immédiate}
\begin{minted}{bash}
# 1. Affectation simple (Texte brut)
prog="date"
echo $prog      # Affiche : date

# 2. Substitution (Exécution)
aujourdhui=$(date)
echo $aujourdhui  # Affiche : Jeu 24 Oct 2024
\end{minted}
  \end{exampleblock}

  \vspace{0.2cm}
  \begin{columns}[t]
    \column{0.55\textwidth}
    \textbf{Exemple concret :}
\begin{minted}{bash}
# Compter les fichiers
nb=$(ls | wc -l)
echo "Il y a $nb fichiers ici."
\end{minted}

    \column{0.4\textwidth}
    \begin{alertblock}{\emoji{warning} Obsolète}
      Évitez les \textit{backticks} : \\
      \texttt{date} \\
      C'est l'ancienne syntaxe (moins lisible).
    \end{alertblock}
  \end{columns}
\end{frame}

% ---

\begin{frame}{Les Flux Standards (Entrées / Sorties)}
  Sous UNIX, chaque programme lancé est automatiquement connecté à 3 "canaux" de données (File Descriptors).

  \vspace{0.3cm}
  \begin{itemize}
    \item \textbf{0 : Entrée Standard (stdin)}
    \begin{itemize}
        \item \emoji{keyboard} Par défaut : Le Clavier.
        \item C'est ce que le programme lit.
    \end{itemize}

    \item \textbf{1 : Sortie Standard (stdout)}
    \begin{itemize}
        \item \emoji{desktop-computer} Par défaut : L'Écran (Terminal).
        \item C'est là que le programme envoie ses résultats normaux.
    \end{itemize}

    \item \textbf{2 : Sortie d'Erreur (stderr)}
    \begin{itemize}
        \item \emoji{warning} Par défaut : L'Écran (aussi !).
        \item C'est là que le programme envoie les messages d'erreur.
    \end{itemize}
  \end{itemize}

  \vspace{0.3cm}
  \begin{alertblock}{Pourquoi séparer 1 et 2 ?}
    Pour pouvoir enregistrer les résultats dans un fichier (données propres) tout en continuant à voir les erreurs s'afficher à l'écran.
  \end{alertblock}
\end{frame}

% ---

\begin{frame}[fragile]{Rediriger les sorties vers des fichiers}
  On peut détourner le flux standard (1) ou d'erreur (2) vers un fichier avec des opérateurs spécifiques.

  \vspace{0.2cm}
  \begin{columns}[t]
    \column{0.5\textwidth}
    \begin{block}{Redirection Simple \texttt{>}}
      \textbf{Écrase} le contenu du fichier (remise à zéro).
\begin{minted}{bash}
# Sauver la liste dans un fichier
ls > liste.txt

# Le fichier est vidé avant !
echo "Nouveau" > liste.txt
\end{minted}
    \end{block}

    \column{0.5\textwidth}
    \begin{block}{Redirection Double \texttt{>>}}
      \textbf{Ajoute} à la fin du fichier (Append).
\begin{minted}{bash}
# Ajoute une ligne à la fin
echo "Fin" >> liste.txt

# Log (historique)
date >> journal.log
\end{minted}
    \end{block}
  \end{columns}

  \vspace{0.3cm}
  \textbf{Et les erreurs (Canal 2) ?}
  \begin{itemize}
    \item Il faut préciser le numéro \texttt{2} avant le chevron.
    \item \texttt{gcc main.c \textbf{2>} erreurs.log} (Seules les erreurs vont dans le fichier).
  \end{itemize}
\end{frame}

% ---

%\begin{frame}{Redirections et Pipes (Tuyaux)}
%  En UNIX, la philosophie est de créer de petits outils qui font une seule chose, et de les connecter entre eux.
%
%  \vspace{0.2cm}
%  \textbf{1. Les Redirections vers des fichiers :}
%  \begin{itemize}
%    \item \texttt{\textbf{>}} : Redirige la sortie (écrase le fichier).
%    \item \texttt{\textbf{>>}} : Redirige la sortie (ajoute à la fin du fichier).
%    \item \textit{Exemple :} \texttt{echo "Log fini" >> rapport.txt}
%  \end{itemize}
%
%  \vspace{0.3cm}
%  \textbf{2. Le Pipe (Le tuyau \texttt{|}) :}
%  \begin{itemize}
%    \item Connecte la sortie d'une commande à l'entrée de la suivante.
%    \item C'est de la plomberie logicielle !
%  \end{itemize}
%
%  \begin{exampleblock}{Exemple puissant}
%    \texttt{ls -l | grep ".txt" | wc -l}
%    \begin{enumerate}
%        \footnotesize
%        \item \texttt{ls -l} : Liste tout le contenu.
%        \item \texttt{grep ".txt"} : Ne garde que les lignes contenant ".txt".
%        \item \texttt{wc -l} : Compte le nombre de lignes restantes.
%    \end{enumerate}
%    $\rightarrow$ \textbf{Résultat :} Affiche le nombre de fichiers texte.
%  \end{exampleblock}
%\end{frame}

% ---

