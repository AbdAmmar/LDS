
% ---

\begin{frame}{Niveaux d'abstraction et exécution}
  Pour communiquer avec la machine, il existe plusieurs niveaux de langages :

  \vspace{0.3cm}
  \begin{itemize}
    \setlength\itemsep{1em}

    \item \textbf{Langage Assembleur (Bas niveau)} :
    \begin{itemize}
        \footnotesize
        \item Représentation lisible du code machine (binaire).
        \item Très rapide, mais difficile à écrire et dépendant du processeur.
    \end{itemize}

    \item \textbf{Langages Compilés (ex: C, C++, Rust)} :
    \begin{itemize}
        \footnotesize
        \item Le code source est traduit en un exécutable binaire \textbf{avant} l'exécution.
        \item \textbf{Avantage} : Performance maximale.
        \item \textbf{Inconvénient} : Étape de compilation nécessaire à chaque changement.
    \end{itemize}

    \item \textbf{Langages Interprétés / Scripts (ex: Bash, Python)} :
    \begin{itemize}
        \footnotesize
        \item Le code est lu et exécuté ligne par ligne par un interpréteur.
        \item \textbf{Avantage} : Développement rapide, pas de compilation.
        \item \textbf{Inconvénient} : Plus lent à l'exécution.
    \end{itemize}
  \end{itemize}
\end{frame}

% ---

\begin{frame}{Le rôle des langages de script}
  \begin{itemize}
    \item script $=$ fichier texte avec des commandes exécutées par l'interpréteur (ici, le shell)

    \item \textbf{Pourquoi scripter ?}
    \begin{itemize}
      \item \textbf{Automatisation} : Éviter de taper 50 fois la même commande. Si une tâche prend plus de 1 minute, on l'automatise.
      \item \textbf{La "Glu" du système} : Connecter différents programmes entre eux (ex: prendre la sortie d'un calcul en C et l'envoyer dans un graphique Python).
      \item \textbf{Administration} : Gérer les fichiers, les utilisateurs et les configurations du système.
    \end{itemize}
  \end{itemize}
\end{frame}

% ---

\begin{frame}{Pourquoi Bash ?}
  Avec la popularité de Python, pourquoi apprendre le Bash en L1 ?

  \vspace{0.3cm}
  \begin{columns}
    \column{0.6\textwidth}
    \begin{itemize}
        \setlength\itemsep{1em}
        \item \textbf{Universalité} : Présent par défaut sur quasi tous les serveurs Linux/Unix du monde. Pas besoin d'installer quoi que ce soit.
        \item \textbf{Natif} : Il est conçu pour manipuler des fichiers et lancer des processus. Faire la même chose en C ou Java demanderait 10 fois plus de lignes de code.
        \item \textbf{Héritage} : Comprendre Bash, c'est comprendre comment fonctionne l'OS.
    \end{itemize}

    \column{0.4\textwidth}
    \centering
    %% Tu peux mettre un logo Bash ou une icone de serveur ici
    \rule{3cm}{3cm} % Placeholder carré noir
    %\captionof{figure}{L'outil de l'admin sys}
  \end{columns}
\end{frame}

% ---

\begin{frame}{Structure d'un script Bash}
  Un script Bash est un simple fichier texte. Par convention, on lui donne l'extension \texttt{.sh}.

  \vspace{0.3cm}
  \begin{exampleblock}{Exemple : \texttt{bonjour.sh}}
    \texttt{\#!/bin/bash} \\
    \texttt{\# Ceci est un commentaire} \\
    \texttt{echo "Bonjour tout le monde !"}
  \end{exampleblock}

  \vspace{0.3cm}
  \begin{itemize}
    \item \textbf{Le Shebang (\texttt{\#!})} :
    \begin{itemize}
        \footnotesize
        \item C'est obligatoirement la 1\textsuperscript{ère} ligne.
        \item \texttt{\#!/bin/bash} indique au système : "Utilise le programme \textit{bash} situé dans \textit{/bin} pour exécuter ce fichier".
    \end{itemize}
    \item \textbf{\texttt{echo}} : Commande pour afficher du texte à l'écran.
    \item \textbf{\texttt{\#}} : Tout ce qui suit est ignoré (commentaire).
  \end{itemize}
\end{frame}

\begin{frame}{Rendre le script exécutable}
  Par défaut, pour des raisons de sécurité, un fichier texte n'est pas exécutable.

  \begin{alertblock}{Le piège du débutant}
    Si vous tapez juste \texttt{./bonjour.sh}, vous aurez l'erreur : \\
    \texttt{Permission denied (Permission non accordée)}
  \end{alertblock}

  \vspace{0.3cm}
  \textbf{La solution : changer les droits (permissions)}

  \begin{enumerate}
    \item Rendre exécutable (une seule fois) :
    \par\centering\fbox{\texttt{chmod +x bonjour.sh}}

    \item Exécuter le script :
    \par\centering\fbox{\texttt{./bonjour.sh}}
  \end{enumerate}

  \vspace{0.2cm}
  \footnotesize
  \textit{Note : Le \texttt{./} signifie "dans le dossier courant". Sans cela, le shell cherche la commande dans les dossiers système.}
\end{frame}

\begin{frame}{Les Variables en Bash}
  Bash n'est pas typé (tout est considéré comme du texte par défaut).

  \begin{columns}[t]
    \column{0.5\textwidth}
    \begin{block}{1. Affectation (Écriture)}
      Syntaxe : \texttt{NOM=valeur}
      \vspace{0.1cm}
      \begin{itemize}
        \item \textcolor{red}{\textbf{Interdit :}} Pas d'espaces autour du \texttt{=} !
        \item \texttt{A = 10} \emoji{cross-mark} (Erreur)
        \item \texttt{A=10} \emoji{check-mark-button} (Correct)
      \end{itemize}
    \end{block}

    \column{0.5\textwidth}
    \begin{block}{2. Utilisation (Lecture)}
      Syntaxe : \texttt{\$NOM}
      \vspace{0.1cm}
      \begin{itemize}
        \item Le signe \texttt{\$} demande au shell de remplacer le nom par sa valeur.
        \item \texttt{echo \$A} $\rightarrow$ Affiche \texttt{10}
      \end{itemize}
    \end{block}
  \end{columns}

  \vspace{0.5cm}
  \begin{exampleblock}{Exemple complet}
    \texttt{prenom="Jean"} \\
    \texttt{echo "Salut \$prenom"} $\rightarrow$ Affiche : Salut Jean
  \end{exampleblock}
\end{frame}

% ---

\begin{frame}[fragile]{Les Conditions (If / Else)}
  La structure conditionnelle permet d'exécuter du code si un test est vrai.
  \vspace{0.2cm}

  \begin{columns}
    \column{0.5\textwidth}
    \begin{exampleblock}{Syntaxe générale}
\begin{minted}{bash}
if [ condition ]; then
    # commandes si vrai
elif [ autre_cond ]; then
    # sinon si...
else
    # sinon...
fi
\end{minted}
    \end{exampleblock}

    \column{0.5\textwidth}
    \begin{alertblock}{Règle d'or : LES ESPACES}
      En Bash, \texttt{[} est une commande. Il faut \textbf{toujours} des espaces autour !

      \vspace{0.2cm}
      \texttt{if [\$A = "oui"]} \quad \emoji{cross-mark} \\
      \texttt{if [ \$A = "oui" ]} \quad \emoji{check-mark-button}
    \end{alertblock}
  \end{columns}
\end{frame}

% ---

\begin{frame}[fragile]{Les Opérateurs de Comparaison}
  Contrairement au C ou Java, les opérateurs changent selon qu'on compare des \textbf{nombres} ou des \textbf{chaînes de caractères}.

  \begin{itemize}
    \item Nombres
    \begin{itemize}
      \item \texttt{-eq} / \texttt{-ne} : Égal / Différent (\textit{Equal/Not Equal})
      \item \texttt{-lt} / \texttt{-le} : Plus petit (\textit{Lower Than/Lower Equal})
      \item \texttt{-gt} / \texttt{-ge} : Plus grand (\textit{Greater Than})
    \end{itemize}

    \item Texte
    \begin{itemize}
      \item \texttt{=} : Identique 
      \item \texttt{!=} : Différent
    \end{itemize}

    \item Fichiers
    \begin{itemize}
      \item \texttt{-f fichier} : Le fichier existe 
      \item \texttt{-d dossier} : Le dossier existe
    \end{itemize}
  \end{itemize}

  \vspace{0.2cm}
  \centering
\begin{minted}{bash}
if [ $age -ge 18 ]; then 
  echo "Majeur"
fi
\end{minted}
\end{frame}

% ---

\begin{frame}[fragile]{La Boucle FOR (Pour chaque...)}
  Idéale pour parcourir une liste d'éléments (fichiers, mots, séquence).

  \vspace{0.3cm}
  \begin{block}{Syntaxe}
    \texttt{for \textbf{variable} in \textbf{liste}; do} \\
    \hspace*{1em} \texttt{commandes...} \\
    \texttt{done}
  \end{block}

  \vspace{0.3cm}
  \begin{columns}[t]
    \column{0.48\textwidth}
    \textbf{Exemple 1 : Liste explicite}
    \begin{exampleblock}{}
\begin{minted}{bash}
for couleur in rouge vert bleu
do
  echo "Couleur : $couleur"
done
\end{minted}
    \end{exampleblock}

    \column{0.48\textwidth}
    \textbf{Exemple 2 : Fichiers (Globbing)}
    \begin{exampleblock}{}
\begin{minted}{bash}
# Affiche tous les fichiers .txt
for fichier in *.txt
do
  echo "Trouvé : $fichier"
done
\end{minted}
    \end{exampleblock}
  \end{columns}
\end{frame}

% ---

\begin{frame}[fragile]{La Boucle WHILE (Tant que...)}
  Répète les commandes tant que la condition est vraie.

  \vspace{0.3cm}
  \begin{exampleblock}{Exemple : Un compte à rebours}
\begin{minted}{bash}
compteur=5

while [ $compteur -gt 0 ]; do
    echo $compteur
    # Syntaxe arithmétique double parenthèse
    ((compteur--)) 
done

echo "Décollage !"
\end{minted}
  \end{exampleblock}

  \vspace{0.3cm}
  \begin{itemize}
    \item Utile pour lire un fichier ligne par ligne ou attendre un événement.
    \item \textbf{Attention aux boucles infinies} : assurez-vous que la condition devienne fausse à un moment donné (ici via \texttt{compteur--}).
  \end{itemize}
\end{frame}

% ---

\begin{frame}{Les Arguments du script}
  On veut souvent passer des informations au script dès son lancement, sans modifier le code.
  \vspace{0.2cm}

  \textbf{Commande :} \texttt{./salut.sh \textcolor{blue}{Pierre} \textcolor{orange}{Paul}}

  \vspace{0.3cm}
  Bash stocke ces mots automatiquement dans des variables numérotées :

  \begin{itemize}
    \setlength\itemsep{1em}
    \item \texttt{\$0} : Le nom du script (\texttt{./salut.sh})
    \item \texttt{\textcolor{blue}{\$1}} : Le premier argument (\texttt{Pierre})
    \item \texttt{\textcolor{orange}{\$2}} : Le deuxième argument (\texttt{Paul})
    \item \texttt{\$\#} : Le nombre total d'arguments (ici \texttt{2})
    \item \texttt{\$@} : La liste de tous les arguments
  \end{itemize}

  \vspace{0.3cm}
  \begin{exampleblock}{Exemple pratique}
    \texttt{echo "Bonjour \$1, comment va \$2 ?"} \\
    $\rightarrow$ Affiche : Bonjour Pierre, comment va Paul ?
  \end{exampleblock}
\end{frame}

% ---

\begin{frame}[fragile]{L'interaction utilisateur (read)}
  Pour demander une information à l'utilisateur pendant l'exécution, on utilise la commande \texttt{read}.

  \vspace{0.5cm}
  \begin{block}{Syntaxe}
    \texttt{read -p "Message à afficher : " nom\_variable}
  \end{block}

  \vspace{0.3cm}
  \textbf{Exemple de script interactif :}
  \begin{exampleblock}{}
\begin{verbatim}
#!/bin/bash

read -p "Quel est votre nom ? " user_name
echo "Bienvenue, $user_name !"

read -p "Voulez-vous continuer ? (o/n) " reponse
if [ "$reponse" = "o" ]; then
    echo "On continue..."
fi
\end{verbatim}
  \end{exampleblock}
\end{frame}

% ---

\begin{frame}{Redirections et Pipes (Tuyaux)}
  En UNIX, la philosophie est de créer de petits outils qui font une seule chose, et de les connecter entre eux.

  \vspace{0.2cm}
  \textbf{1. Les Redirections vers des fichiers :}
  \begin{itemize}
    \item \texttt{\textbf{>}} : Redirige la sortie (écrase le fichier).
    \item \texttt{\textbf{>>}} : Redirige la sortie (ajoute à la fin du fichier).
    \item \textit{Exemple :} \texttt{echo "Log fini" >> rapport.txt}
  \end{itemize}

  \vspace{0.3cm}
  \textbf{2. Le Pipe (Le tuyau \texttt{|}) :}
  \begin{itemize}
    \item Connecte la sortie d'une commande à l'entrée de la suivante.
    \item C'est de la plomberie logicielle !
  \end{itemize}

  \begin{exampleblock}{Exemple puissant}
    \texttt{ls -l | grep ".txt" | wc -l}
    \begin{enumerate}
        \footnotesize
        \item \texttt{ls -l} : Liste tout le contenu.
        \item \texttt{grep ".txt"} : Ne garde que les lignes contenant ".txt".
        \item \texttt{wc -l} : Compte le nombre de lignes restantes.
    \end{enumerate}
    $\rightarrow$ \textbf{Résultat :} Affiche le nombre de fichiers texte.
  \end{exampleblock}
\end{frame}

% ---

\begin{frame}[fragile]{Gestion des erreurs (Code de retour)}
  En UNIX, chaque commande qui se termine renvoie un petit entier au système pour dire comment ça s'est passé : le \textbf{code de retour} (\textit{exit status}).

  \vspace{0.3cm}
  \begin{block}{La convention UNIX}
    \begin{itemize}
      \item \textbf{0} \emoji{check-mark-button} : \textbf{Succès} (Tout s'est bien passé).
      \item \textbf{1 à 255} \emoji{cross-mark} : \textbf{Erreur} (Fichier non trouvé, permission refusée, etc.).
    \end{itemize}
  \end{block}

  \vspace{0.3cm}
  \textbf{Comment l'utiliser ?}
  La variable spéciale \texttt{\textbf{\$?}} contient le code de retour de la \textit{dernière} commande exécutée.

  \begin{exampleblock}{Exemple}
\begin{verbatim}
ls fichier_inexistant.txt
# La commande affiche une erreur à l'écran...

if [ $? -ne 0 ]; then
    echo "Oups ! La commande a échoué."
    exit 1  # On arrête notre script en signalant une erreur
fi
\end{verbatim}
  \end{exampleblock}
\end{frame}

% ---

\begin{frame}{L'Environnement et le PATH}
  Certaines variables sont définies par le système et accessibles partout : ce sont les \textbf{variables d'environnement}.

  \begin{itemize}
    \item \texttt{\$USER} : Votre nom d'utilisateur.
    \item \texttt{\$HOME} : Chemin vers votre dossier personnel.
    \item \texttt{\$PWD} : Dossier courant.
  \end{itemize}

  \vspace{0.3cm}
  \begin{alertblock}{La variable magique : \texttt{\$PATH}}
    Pourquoi tapez-vous \texttt{ls} et pas \texttt{/bin/ls} ?
    \begin{itemize}
        \footnotesize
        \item \texttt{\$PATH} contient une liste de dossiers séparés par des \texttt{:}
        \item Quand vous tapez une commande, le shell cherche le programme dans ces dossiers, l'un après l'autre.
    \end{itemize}
  \end{alertblock}

  \vspace{0.2cm}
  \textbf{Conséquence pour vos scripts :}
  Votre dossier courant n'est pas dans le PATH par défaut. C'est pour cela qu'il faut taper \texttt{\textbf{./}script.sh} (pour dire "cherche ici, pas dans le PATH").
\end{frame}

\begin{frame}{Bonnes pratiques de scripting}
  Pour écrire des scripts robustes et lisibles (et avoir une bonne note !) :

  \vspace{0.3cm}
  \begin{enumerate}
    \setlength\itemsep{1em}
    \item \textbf{Toujours le Shebang} :
    La 1\textsuperscript{ère} ligne doit être \texttt{\#!/bin/bash}.

    \item \textbf{Indentation} :
    Décalez le code à l'intérieur des \texttt{if} et des \texttt{for} (comme en Python ou C).

    \item \textbf{Guillemets} :
    Protégez vos variables avec des guillemets doubles si elles peuvent contenir des espaces.
    \\ \texttt{rm "\$nom\_fichier"} (au cas où le fichier s'appelle "TP 1.txt").

    \item \textbf{Noms parlants} :
    \texttt{\$cpt} est mieux que \texttt{\$x}, mais \texttt{\$compteur} est idéal.

    \item \textbf{Commentaires} :
    Utilisez \texttt{\#} pour expliquer les parties complexes.
  \end{enumerate}
\end{frame}

% ---

\begin{frame}{Le Globbing (Jokers de fichiers)}
  Le \textbf{Globbing} est un mécanisme du Shell pour sélectionner rapidement des fichiers par leurs noms.

  \begin{alertblock}{Important}
    C'est le Shell qui "développe" (remplace) le joker par la liste des fichiers correspondants \textbf{avant} de lancer la commande.
  \end{alertblock}

  \vspace{0.2cm}
  \textbf{Les motifs principaux :}
  \begin{itemize}
    \item \texttt{\textbf{*}} : Remplace n'importe quelle chaîne (vide ou longue).
    \item \texttt{\textbf{?}} : Remplace exactement \textbf{un} caractère.
    \item \texttt{\textbf{[abc]}} : Remplace un seul caractère parmi la liste (a, b ou c).
  \end{itemize}

  \vspace{0.3cm}
  \begin{exampleblock}{Exemples}
    \begin{itemize}
        \item \texttt{ls *.txt} $\rightarrow$ Liste tous les fichiers finissant par .txt
        \item \texttt{rm TP?.c} $\rightarrow$ Supprime \texttt{TP1.c}, \texttt{TP2.c}, mais PAS \texttt{TP10.c}
    \end{itemize}
  \end{exampleblock}
\end{frame}

% ---

\begin{frame}{Les Expressions Régulières (Regex)}
  Une Regex est un motif pour décrire une chaîne de caractères. Elle est utilisée par des outils comme \texttt{grep} pour chercher \textbf{dans le contenu} des fichiers.

  \vspace{0.2cm}
  \textbf{Les métacaractères de base :}
  \begin{itemize}
    \item \texttt{\textbf{\textasciicircum}} (accent circonflexe) : Début de ligne.
    \item \texttt{\textbf{\$}} : Fin de ligne.
    \item \texttt{\textbf{.}} (point) : N'importe quel caractère unique.
    \item \texttt{\textbf{*}} : Répétition (0 ou plusieurs fois) du caractère \textit{précédent}.
  \end{itemize}

  \vspace{0.3cm}
  \begin{exampleblock}{Exemples avec grep}
    \texttt{grep "\textasciicircum int" main.c} \\
    $\rightarrow$ Trouve les lignes qui \textbf{commencent} par "int".

    \texttt{grep "error\$" log.txt} \\
    $\rightarrow$ Trouve les lignes qui \textbf{finissent} par "error".
  \end{exampleblock}
\end{frame}

% ---

\begin{frame}{Attention à la confusion !}
  Le même symbole n'a pas le même sens selon le contexte !

  \vspace{0.2cm}
  \renewcommand{\arraystretch}{1.4}
  \begin{table}
    \centering
    \begin{tabular}{|c|l|l|}
      \hline
      \rowcolor{gray!20}
      \textbf{Symbole} & \textbf{En Globbing (Fichiers)} & \textbf{En Regex (Texte/Grep)} \\
      \hline
      \textbf{\texttt{*}} & N'importe quoi & Répétition du précédent \\
      \hline
      \textbf{\texttt{.}} & Un vrai point (littéral) & N'importe quel caractère \\
      \hline
      \textbf{\texttt{?}} & Un seul caractère & 0 ou 1 fois le précédent (optionnel) \\
      \hline
    \end{tabular}
  \end{table}

  \vspace{0.3cm}
  \textbf{Basique vs Étendue (Extended Regex) :}
  \begin{itemize}
    \item Par défaut, \texttt{grep} utilise les regex basiques (vieux standard).
    \item Pour utiliser des symboles modernes comme \texttt{+} (au moins 1 fois), \texttt{?} (0 ou 1 fois) ou \texttt{|} (OU logique), il faut utiliser :
    \par\centering\fbox{\texttt{grep -E} \quad ou \quad \texttt{egrep}}
  \end{itemize}
\end{frame}

% ---

