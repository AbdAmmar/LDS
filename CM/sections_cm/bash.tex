
% ---

\begin{frame}{Langages Compilés vs Langages Interprétés}
  \setbeamercovered{transparent}

  \begin{itemize}
    \setlength\itemsep{1em}

    \item <1-> Langages Compilés
    \begin{itemize}
      \setlength\itemsep{0.5em}
      \footnotesize
      \item <2-> code source traduit en un binaire avant l'exécution
      \item <3-> avantage : performance maximale
      \item <4-> inconvénient : compilation nécessaire à chaque changement
      \item <5-> ex: C, C++, Rust, Fortran, \ldots
    \end{itemize}

    \item <1-> Langages Interprétés / Scripts
    \begin{itemize}
      \setlength\itemsep{0.5em}
      \footnotesize
      \item <2-> le code est lu et exécuté ligne par ligne par un interpréteur
      \item <3-> avantage : développement rapide, pas de compilation
      \item <4-> inconvénient : plus lent à l'exécution
      \item <5-> ex: Bash, Python, Ruby, Perl, \ldots
    \end{itemize}
  \end{itemize}

\end{frame}

% ---

\begin{frame}{Pourquoi écrire des scripts ?}

  \begin{itemize}
    \setlength\itemsep{1em}

    \item[\emoji{robot}] Automatisation : les tâches répétitives sont ennuyeuses et sources d'erreurs
    \begin{itemize}
      \setlength\itemsep{0.5em}
      \footnotesize
      \item sauvegarder dossier \texttt{\color{blue}/Factures} sur un serveur 
            distant tous les soirs avant de quitter le travail
    \end{itemize}

    \pause

    \item[\emoji{link}] "Glu"
    \begin{itemize}
      \setlength\itemsep{0.5em}
      \footnotesize
      \item lancer un calcul en C $\rightarrow$
            récupérer le résultat $\rightarrow$
            générer un graphique avec Python
    \end{itemize}

    \pause

    \item[\emoji{file-folder}] Gestion de masse
    \begin{itemize}
      \setlength\itemsep{0.5em}
      \footnotesize
      \item Renommer 500 photos de \texttt{IMG\_XXXX.jpg} vers \texttt{Vacances\_XXXX.jpg}
    \end{itemize}
  \end{itemize}

\end{frame}

% ---

\begin{frame}{Quand utiliser Bash}

  \begin{itemize}
    \setlength\itemsep{1em}

    \item[\emoji{check-mark-button}] Cas d'usage idéaux
    \begin{itemize}
      \footnotesize
      \setlength\itemsep{0.5em}
      \item automatisation : tâches planifiées, compilation (build), \ldots
      \pause
      \item manipulation de fichiers : renommage de masse, gestion de dossiers, \ldots
      \pause
      \item analyse textuelle simple : extraire des infos de fichiers de logs %(\texttt{grep}, \texttt{sort}, \texttt{uniq})
      \pause
      \item lancer et connecter des programmes (C/Python) sans "wrapper" complexe
    \end{itemize}

    \pause

    \item[\emoji{cross-mark}] Limites
    \begin{itemize}
      \footnotesize
      \setlength\itemsep{0.5em}
      \item données structurées : analyser du JSON, XML, \ldots
      \pause
      \item mathématiques : pas de gestion native des nombres à virgule flottante
      \pause
      \item le code devient illisible si le projet grossit
      \pause
      \item gestion d'erreurs plus difficile qu'avec un langage moderne
    \end{itemize}
  \end{itemize}

\end{frame}

% ---

\begin{frame}{Les variables}

  \begin{terminal}
    \onslide<1->{
    \prompt\ NOM=TOTO \tcomment{pas besoin de guillemets}

    \prompt\ \shcmd{echo} \$TOTO
    }

    \onslide<2->{
    \prompt\ TOTO
    }

    \onslide<3->{
    \prompt\ NOM =TOTO
    }

    \onslide<4->{
    \prompt\ {\color{red}NOM: command not found}
    }

    \onslide<5->{
    \prompt\ NOM= TOTO
    }

    \onslide<6->{
    \prompt\ {\color{red}TOTO: command not found}
    }
  \end{terminal}

  \onslide<7->{
  \begin{itemize}
    \setlength\itemsep{1em}

    \item variables d'environnement : définies par le système
    \begin{itemize}
      \footnotesize
      \setlength\itemsep{0.5em}
      \item \texttt{\$USER} : nom d'utilisateur
      \item \texttt{\$HOME} : chemin vers le dossier personnel
      \item \texttt{\$PWD} : dossier courant
      \item \texttt{\$PATH} : dossiers où rechercher les programmes (\texttt{ls}, \texttt{pwd}, \texttt{mkdir}, \ldots)
    \end{itemize}
  \end{itemize}
  }

\end{frame}

% ---

\begin{frame}[fragile]{Calculs et Arithmétique}

  Par défaut, Bash considère tout comme du texte

  \begin{terminal}
    \onslide<1->{
    \prompt\ x=10

    \prompt\ y=5

    \prompt\ \shcmd{echo} \$x+\$y
    }

    \onslide<2->{
    \prompt\ 10+5
    }

    \onslide<3->{
    \prompt\ \shcmd{echo} \$((x+y)) \tcomment{pas besoin d'utiliser \$x, \$y}

    \prompt\ 15
    }

    \onslide<4->{
    \prompt\ \shcmd{echo} \$((x\%y))
    }

    \onslide<5->{
    \prompt\ 0
    }

    \onslide<6->{
    \prompt\ ((x++)); \shcmd{echo} \$x
    }

    \onslide<7->{
    \prompt\ 11
    }

    \onslide<8->{
    \prompt\ ((x+=1)); \shcmd{echo} \$x

    \prompt\ 12
    }

    \onslide<9->{
    \prompt\ \shcmd{echo} \$((10 / 3))
    }

    \onslide<10->{
    \prompt\ 3
    }
  \end{terminal}

\end{frame}

% ---

\begin{frame}[fragile]{Conditions}

  \begin{terminal}
    \onslide<1->{
    \prompt\ \tcomment{Le fichier "fichier.txt" existe-t-il ?}
    }

    \onslide<2->{
    \prompt\ \shcmd{test} -f "fichier.txt"  \tcomment{Historique}
    }

    \onslide<3->{
    \prompt\ \shcmd{[} -f "fichier.txt" \shcmd{]}  \tcomment{POSIX (Attention aux espaces !)}
    }

    \onslide<4->{
    \prompt\ \shcmd{[[} -f "fichier.txt" \shcmd{]]}  \tcomment{Spécifique Bash (Recommandé)}
    }
  \end{terminal}

  \begin{itemize}
  \setlength\itemsep{0.75em}

    \onslide<5->{
    \item nombres : \texttt{[[ a -eq b ]]}
    \begin{itemize}
      \setlength\itemsep{0.25em}
      \footnotesize
      \item \texttt{-eq} (equal) / \texttt{-ne} (not equal)
      \item \texttt{-lt} (lower than) / \texttt{-le} (lower or equal)
      \item \texttt{-gt} (greater than) / \texttt{-ge} (greater or equal)
    \end{itemize}
    }

    % ---

    \onslide<6->{
    \item texte (chaînes de caractères) : \texttt{[[ a == b ]]}
    \begin{itemize}
      \setlength\itemsep{0.5em}
      \footnotesize
      \item \texttt{==} : identique (préféré à \texttt{=})
      \item \texttt{!=} : différent
    \end{itemize}
    }

    % ---

    \onslide<7->{
    \item[\emoji{warning}]
    code de retour (\texttt{\$?})
    \begin{itemize}
      \setlength\itemsep{0.5em}
      \footnotesize
      \item 0 : succès (Vrai)
      \item 1 (ou plus) : échec (Faux)
    \end{itemize}
    }

  \end{itemize}

\end{frame}

% ---

\begin{frame}[fragile]{Boucle FOR}

\begin{minted}{bash}
for variable in liste
do
  # commandes...
done
\end{minted}

  \pause

  \begin{terminal}
    \onslide<2->{
    \prompt\ \shcmd{for} i \shcmd{in} rouge vert bleu{\color{red};} \shcmd{do} \shcmd{echo} \$i{\color{red};} \shcmd{done}
    }

    \onslide<3->{
    \prompt\ rouge
  
    \prompt\ vert
  
    \prompt\ bleu
    }
  
    \onslide<4->{
    \prompt\ 
  
    \prompt\ \shcmd{for} i \shcmd{in} \{1..3\}; \shcmd{do} \shcmd{echo} \$i; \shcmd{done}
    }
  
    \onslide<5->{
    \prompt\ 1
  
    \prompt\ 2
  
    \prompt\ 3
    }
  \end{terminal}

\end{frame}

% ---

\begin{frame}[fragile]{if / elif / else}

  \begin{minted}{bash}
if [[ condition ]]; then
    # commandes si vrai
elif [[ autre_cond ]]; then
    # sinon si...
else
    # sinon...
fi
  \end{minted}

  \begin{terminal}
    \footnotesize
    \prompt\ \tcomment{condition1 et condition2 :}

    \prompt\ condition1 \&\& condition2

    \prompt\ \tcomment{condition1 ou condition2 :}

    \prompt\ condition1 || condition2

    \prompt\ \tcomment{négation :}

    \prompt\ ! condition
  \end{terminal}

\end{frame}

% ---

\begin{frame}[fragile]{Exemples}

  \begin{terminal}
    \footnotesize
    \prompt\ a=5; b=1

    \prompt\ \shcmd{[[} a > b \shcmd{]]} \&\& \shcmd{echo} "a > b"

    \prompt\

    \prompt\ \shcmd{[[} a < b \shcmd{]]} \&\& \shcmd{echo} "a < b"

    \prompt\ a < b

    \prompt\ \shcmd{[[} a -gt b \shcmd{]]} \&\& \shcmd{echo} "a > b"

    \prompt\ a > b

    \prompt\ ((a > b)) \&\& \shcmd{echo} "a > b"

    \prompt\ a > b
  \end{terminal}

\end{frame}

% ---

\begin{frame}[fragile]{Boucle While}

\begin{minted}{bash}
while [[ condition ]]; do
    # Commandes à répéter
done
\end{minted}

\begin{minted}{bash}
while true; do
    # Commandes à répéter
    if [[ condition_fin ]]; then
        break
    fi
done
\end{minted}

  \begin{itemize}
    \item[\emoji{warning}] Attention aux boucles infinies
  \end{itemize}
\end{frame}

% ---

\begin{frame}[fragile]{Les Choix Multiples (Case)}
  Quand on a beaucoup de conditions à tester sur une seule variable, \texttt{case} 
  est plus propre qu'une suite de \texttt{if / elif / elif}.

  \begin{block}{Syntaxe Générale}
\begin{minted}{bash}
case $variable in
    motif1)
        commandes ;;
    motif2 | motif3)    # Le tuyau | signifie OU
        commandes ;;
    *)                  # * capte tout le reste (Default)
        commandes_par_defaut ;;
esac
\end{minted}
  \end{block}

  \vspace{0.1cm}
  \footnotesize
  \textbf{Attention :} Ne pas oublier le double point-virgule \texttt{;;} à la fin de chaque bloc !
\end{frame}

% ---

\begin{frame}[fragile]{Exemple}

  \begin{exampleblock}{Exemple : Gestion d'une réponse utilisateur}
\begin{minted}{bash}
read -p "Voulez-vous continuer ? (oui/non) " rep

case $rep in
    # Accepte "o", "O", "oui", "Oui", "OUI"...
    [oO] | [oO][uU][iI])
        echo "C'est parti !" ;;
    [nN]*)
        echo "Arrêt du script."
    *)
        echo "Je n'ai pas compris..." ;;
esac
\end{minted}
  \end{exampleblock}

\end{frame}

% ---

\begin{frame}[fragile]{Script Bash}

  \begin{itemize}

    \item Nommage du fichier :
    \begin{itemize}
      \footnotesize
      \item [\emoji{check-mark-button}] Lettres (a-z), chiffres (0-9), tirets (\texttt{-}, \texttt{\_}) et point (\texttt{.})
      \item [\emoji{cross-mark}] Espaces et caractères accentués (é, à, \ldots)
      \item Extension : \texttt{.sh} : pour aider l'éditeur de texte
    \end{itemize}

    \item fichier \texttt{hello.sh}
\begin{minted}{bash}
# Ceci est un commentaire
echo "Hello World!"
\end{minted}

    pour lancer
    \begin{terminal}
      \prompt\ \shcmd{bash} hello.sh

      \prompt\ Hello World!
    \end{terminal}
  \end{itemize}

\end{frame}

% ---

\begin{frame}[fragile]{Script Bash}

  \begin{itemize}

    \item Shebang  (1\textsuperscript{ère} ligne) : indique quel interpréteur utiliser
\begin{minted}{bash}
#!/usr/bin/env bash
echo "Hello World!"
\end{minted}

    \item alternative (moins portable)
\begin{minted}{bash}
#!/bin/bash
\end{minted}

    \begin{terminal}
      \prompt\ \shcmd{./hello.sh}

      \prompt\ bash: ./hello.sh: Permission denied

      \prompt\ \tcomment{changer les permissions}

      \prompt\ \shcmd{chmod} +x hello.sh

      \prompt\ \shcmd{./hello.sh}

      \prompt\ Hello World!
    \end{terminal}
  \end{itemize}

\end{frame}

% ---

\begin{frame}[fragile]{Arguments du script}

  \begin{itemize}
    \item \texttt{\$0} : Le nom du script (avec le chemin)

    \item \texttt{\$1} : Le premier argument

    \item \texttt{\$2} : Le deuxième argument

    \item \texttt{\$\#} : Le nombre total d'arguments

    \item \texttt{\$@} : La liste de tous les arguments
  \end{itemize}
 
\end{frame}
% ---

\begin{frame}[fragile]{Exemple}

  \begin{itemize}
 
    \item script \texttt{hello.sh}
\begin{minted}{bash}
#!/usr/bin/env bash
echo "Prenom: $0"
echo "Age: $1 ans"
\end{minted}

    \begin{terminal}
      \footnotesize
      \prompt\ \shcmd{./hello.sh} Toto 20

      \prompt\ Prenom: Toto

      \prompt\ Age: 20 ans

      \prompt\ \shcmd{./hello.sh} Jean Christophe 20

      \prompt\ Prenom: Jean

      \prompt\ Age: Christophe ans

      \prompt\ \shcmd{./hello.sh} "Jean Christophe" 20

      \prompt\ Prenom: Jean Christophe

      \prompt\ Age: 20 ans
    \end{terminal}

  \end{itemize}

\end{frame}

% ---

\begin{frame}[fragile]{Fonctions}

  \begin{itemize}

    \item Déclaration et Appel
    \begin{itemize}
      \footnotesize
      \item on définit la fonction avec des parenthèses vides \texttt{()}
      \item on l'appelle simplement par son nom (sans parenthèses)
    \end{itemize}

\begin{minted}{bash}
# Définition
ma_fonction() {
    echo "Hello!"
}

# Appel
ma_fonction
\end{minted}
  \end{itemize}

\end{frame}

% ---

\begin{frame}[fragile]{Fonctions}

  \begin{itemize}

    \item arguments
    \begin{itemize}
      \footnotesize
      \item on passe les valeurs à l'appel : \\ \texttt{ma\_fonc \textcolor{blue}{arg1} \textcolor{orange}{arg2}}
      \item on les récupère dans la fonction avec \texttt{\$1}, \texttt{\$2} \ldots
    \end{itemize}

    \item variables locales
    \begin{itemize}
      \footnotesize
      \item par défaut, toute variable est globale
      \item on utilise \texttt{local} pour confiner une variable à la fonction
    \end{itemize}

\begin{minted}{bash}
additionner() {
    local resultat=$(( $1 + $2 ))
    echo "La somme est : $resultat"
}

additionner 10 5  # Affiche : La somme est : 15
# echo $resultat  # Erreur car la variable est locale
\end{minted}

  \end{itemize}

\end{frame}

% ---

\begin{frame}[fragile]{Résultat d'une commande}

  \begin{itemize}

    \item Substitution de commande
    \begin{itemize}
      \footnotesize
      \item syntaxe : \texttt{\$(commande)}
      \item Bash exécute la commande entre parenthèses
      \item il remplace l'expression par la sortie (texte) de cette commande
      \item les \textit{backticks} \texttt{`commande`} sont obsolètes
    \end{itemize}

\begin{minted}{bash}
# 1. Affectation simple (Texte brut)
prog="date"
echo $prog      # Affiche : date

# 2. Substitution (Exécution)
aujourdhui=$(date)
echo $aujourdhui  # Affiche : Jeu 24 Oct 2024
\end{minted}

  \end{itemize}

\end{frame}

% ---

\begin{frame}{Flux standards (Entrées / Sorties)}

  Sous UNIX, chaque programme lancé est automatiquement connecté à 
  3 "canaux" de données (File Descriptors)

  \vspace{0.3cm}
  \begin{itemize}
    \item 0 : Entrée Standard (stdin)
    \begin{itemize}
      \footnotesize
      \item par défaut : Le clavier
      \item c'est ce que le programme lit
    \end{itemize}

    \item 1 : Sortie Standard (stdout)
    \begin{itemize}
      \footnotesize
      \item par défaut : L'écran (Terminal)
      \item c'est là que le programme envoie ses résultats normaux
    \end{itemize}

    \item 2 : Sortie d'Erreur (stderr)
    \begin{itemize}
      \footnotesize
      \item par défaut : L'écran
      \item c'est là que le programme envoie les messages d'erreur
    \end{itemize}

    \item Pourquoi séparer 1 et 2 ? \\
          pour pouvoir enregistrer les résultats dans un fichier (données propres) tout 
          en continuant à voir les erreurs s'afficher à l'écran
  \end{itemize}

\end{frame}

% ---

\begin{frame}[fragile]{Rediriger les sorties vers des fichiers}

  \begin{itemize}
    \item Redirection simple (\texttt{>}) : Écrase le contenu du fichier (remise à zéro)
\begin{minted}{bash}
# Sauver la liste dans un fichier
ls > liste.txt

# Le fichier est vidé avant !
echo "Nouveau" > liste.txt
\end{minted}

    \item Redirection double (\texttt{>>}) : Ajoute à la fin du fichier
\begin{minted}{bash}
# Ajoute une ligne à la fin
echo "Fin" >> liste.txt
\end{minted}

    \item Et les erreurs (Canal 2) ?
    \begin{itemize}
      \footnotesize
      \item Il faut préciser le numéro \texttt{2} avant le chevron
      \item \texttt{gcc main.c \textbf{2>} erreurs.log} (Seules les erreurs vont dans le fichier)
    \end{itemize}

  \end{itemize}

\end{frame}

% ---

\begin{frame}[fragile]{Le Pipe (tuyau) \texttt{|}}

  \begin{itemize}
    \item Philosophie UNIX : Créer de petits outils qui font une 
          seule chose et les combiner

    \item Le Pipe \texttt{|} prend la sortie standard de la commande de gauche 
          et l'injecte directement comme entrée de la commande de droite \\
          \texttt{\textbf{Commande\_A} \quad \textcolor{blue}{1 (Sortie)} 
          \quad $\xrightarrow{\text{\Large |}}$ \quad 
          \textcolor{blue}{0 (Entrée)} \quad \textbf{Commande\_B}}

    \begin{minted}{bash}
# sans tuyau
ls -l > temp.txt
grep ".txt" temp.txt > selection.txt
wc -l selection.txt
rm temp.txt selection.txt

# avec tuyau
ls -l | grep ".txt" | wc -l
    \end{minted}

  \end{itemize}

\end{frame}

% ---

