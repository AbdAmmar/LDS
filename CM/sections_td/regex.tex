
% ---

\begin{frame}{Introduction aux Expressions Régulières (Regex)}

  \begin{itemize}
    \setlength\itemsep{1em}

    \item une expression régulière est une chaîne de caractères décrivant 
          un \textbf{motif de recherche} (pattern) dans du texte

    \pause
    
    \item Globbing vs Regex
    \begin{itemize}
      \setlength\itemsep{0.5em}
      \footnotesize
      \item Globbing : chercher des \textit{fichiers}
      \item Regex : chercher du \textit{texte} à l'intérieur de fichiers ou de flux
    \end{itemize}

    \pause

    \item outils courants
    \begin{itemize}
      \setlength\itemsep{0.5em}
      \footnotesize
      \item \texttt{grep} : filtrer des lignes contenant un motif spécifique
      \begin{terminal}
          \prompt\ \shcmd{grep} 'Erreur' \tcomment{lignes contenant "Erreur"}
      \end{terminal}
      \item \texttt{sed} : modifier du texte en temps réel (remplacements, suppressions, etc.)
      \item \texttt{awk} : extraire et formater des données structurées (colonnes, calculs, etc.)
    \end{itemize}
  \end{itemize}

\end{frame}

% ---

\begin{frame}{Point (\texttt{.}) et Ancrages (\texttt{\^{}, \$})}

  \begin{itemize}
    \setlength\itemsep{1em}

    \item le point \texttt{.} correspond à \textbf{n'importe quel caractère} %(sauf le saut de ligne)
    \begin{terminal}
        \prompt\ \shcmd{grep} 'chat.'

        \prompt\ chat1 chata chat!
    \end{terminal}

    \pause

    \item les ancrages (début et fin de ligne) ne correspondent pas à un caractère, 
          mais à une \textbf{position}
    \begin{itemize}
      \setlength\itemsep{0.5em}
      \footnotesize
      \item \texttt{\^{}} : début de la ligne
      \item \texttt{\$} : fin de la ligne
    \end{itemize}

    \begin{terminal}
        \prompt\ \shcmd{grep} '\^{}Erreur' \tcomment{lignes commençant par "Erreur"}

        \prompt\ \shcmd{grep} 'petit\$' \tcomment{lignes finissant par "petit"}

        \prompt\ \shcmd{grep} '\^{}fin\$' \tcomment{lignes contenant exactement le mot "fin"}
    \end{terminal}
  \end{itemize}

\end{frame}

% ---

\begin{frame}{Classes de Caractères \texttt{[ ]}}

  \begin{itemize}
    \setlength\itemsep{1em}

    \item presque comme le globbing
    \begin{itemize}
      \setlength\itemsep{0.5em}
      \footnotesize
      \item \texttt{[abc]} : soit a, soit b, soit c
      \item \texttt{[a-z]} : une lettre minuscule
    \end{itemize}

    \pause

    \item les regex utilisent l'accent circonflexe \texttt{\^{}} \textbf{à l'intérieur} des crochets 
          pour dire "tout sauf"

    \pause

    \item Exemples

    \begin{terminal}
      \prompt\ \shcmd{grep} 'gr[ai]s' \tcomment{"gras" ou "gris"}

      \prompt\ \shcmd{grep} '202[0-9]' \tcomment{une année de 2020 à 2029}

      \prompt\ \shcmd{grep} '[\^{}0-9]' \tcomment{tout caractère qui n'est pas un chiffre}
    \end{terminal}
  \end{itemize}

\end{frame}

% ---

\begin{frame}{Astérisque : \texttt{*}}

  \begin{itemize}
    \setlength\itemsep{1em}

    \item l'astérisque signifie ``zéro ou plusieurs occurrences'' du caractère (ou du groupe) qui le \textbf{précède}

    \begin{terminal}
      \prompt\ \shcmd{grep} 'a*' \tcomment{0 ou plusieurs "a"}

      \prompt\ \shcmd{grep} 'ab*' \tcomment{"a" suivi de 0 ou plusieurs "b"}

      \prompt\ \shcmd{grep} 'go*d' \tcomment{"gd", "god", "good", goood, etc.}
    \end{terminal}
  
  \end{itemize}

\end{frame}

% ---

\begin{frame}{Regex étendues : Quantificateurs (\texttt{?, +, \{n\}, \{m,n\}})}

  \begin{itemize}
    \setlength\itemsep{1em}

    \item le quantificateur s'applique \textbf{toujours} à l'élément qui le précède

    \begin{itemize}
      \setlength\itemsep{0.5em}
      \footnotesize

      \pause

      \item \texttt{?} : 0 ou 1 fois
      \begin{terminal}
        \prompt\ \shcmd{grep} -E 'colou?r' \tcomment{"color", "colour"}

        \prompt\ \shcmd{grep} 'colou\textbackslash?r'
      \end{terminal}

      \pause

      \item \texttt{+} :  1 ou plusieurs fois
      \begin{terminal}
        \prompt\ \shcmd{grep} -E 'go+d' \tcomment{"god", "good", "goood", etc.}
      \end{terminal}

      \pause

      \item \texttt{\{n\}} : exactement n fois
      \begin{terminal}
        \prompt\ \shcmd{grep} -E 'ba\{3\}c' \tcomment{"baaac"}
      \end{terminal}

      \pause

      \item \texttt{\{m,n\}} : entre m et n fois
      \begin{terminal}
        \prompt\ \shcmd{grep} -E 'ea\{2,3\}z' \tcomment{"eaaz", "eaaaz"}
      \end{terminal}
    \end{itemize}
  \end{itemize}

\end{frame}

% ---

\begin{frame}{Regex étendues : Pipe \texttt{|} et Parenthèses \texttt{( )}}

  \begin{itemize}
    \setlength\itemsep{1em}

    \item le pipe \texttt{|} agit comme un ``ou logique''
    \begin{terminal}
      \prompt\ \shcmd{grep} -E 'Err|Warning' \tcomment{lignes avec "Err" ou "Warning"}
    \end{terminal}

    \pause

    \item les parenthèses \texttt{( )} servent à limiter la portée d'une
          alternative ou d'un quantificateur
    \begin{terminal}
      \prompt\ \shcmd{grep} -E 'gri|os' \tcomment{cherche "gri" ou "os"}

      \prompt\ \shcmd{grep} -E 'gr(i|o)s' \tcomment{cherche "gris" ou "gros"}

      \prompt\ \shcmd{grep} -E 'ha+' \tcomment{cherche "ha", "haa", "haaa", etc}

      \prompt\ \shcmd{grep} -E '(ha)+' \tcomment{cherche "ha", "haha", "hahaha", etc}
    \end{terminal}
  \end{itemize}

\end{frame}

% ---

\begin{frame}{Caractères spéciaux et Échappement}

  Comment chercher un vrai point \texttt{.}, une vraie étoile \texttt{*}, etc. ?

  \begin{itemize}
    \setlength\itemsep{1em}

    \item le backslash $\textbackslash$ annule la signification spéciale du caractère qui suit

    \begin{terminal}
      \prompt\ \shcmd{grep} 'google.com' \tcomment{"google.com", "googleAcom", etc.}

      \prompt\ \shcmd{grep} 'google\textbackslash.com' \tcomment{"google.com"}

      \prompt\ \shcmd{grep} '3 \textbackslash* 4' \tcomment{"3 * 4"}

        \prompt\ \shcmd{grep} -E 'colou\textbackslash?r' \tcomment{"colou?r"}
    \end{terminal}
  \end{itemize}

\end{frame}

% ---

