\documentclass[11pt,a4paper]{article}

\usepackage[T1]{fontenc}
\usepackage[french]{babel}
\usepackage{geometry}

\usepackage{../tdstyle}

\geometry{margin=2.5cm}

\title{TD1 -- Langages de Script}
\author{Abdallah Ammar}
\date{\today}

\begin{document}
\maketitle



\begin{warningbox}
Le symbole \texttt{\$} affiché au début des commandes correspond à l'invite du terminal.
Il sert uniquement à indiquer que la commande doit être tapée, mais ne fait pas partie
de la commande elle-même.
\end{warningbox}


\begin{warningbox}
Il est fortement recommandé de taper les commandes à la main afin de se familiariser
avec le terminal.
\end{warningbox}


\begin{warningbox}
La commande \texttt{apt} est spécifique aux distributions Linux basées sur Debian
(Ubuntu, WSL Ubuntu).
Sur macOS, l'installation de logiciels se fait généralement avec \texttt{brew}.
Dans ce TD, les commandes \texttt{apt} sont à exécuter uniquement sous Linux ou WSL.
\end{warningbox}


Dans le terminal, il est possible de réutiliser et de modifier des commandes déjà tapées.
Les flèches du clavier permettent de naviguer dans l'historique des commandes :
\begin{itemize}
    \item flèche vers le haut : commande précédente ;
    \item flèche vers le bas : commande suivante.
\end{itemize}

Il est également possible d'utiliser la touche \texttt{TAB} pour compléter automatiquement
les noms de commandes, de fichiers ou de répertoires.
Cette fonctionnalité permet d'éviter les fautes de frappe et d'accélérer la saisie.

L'historique des commandes peut être affiché avec la commande suivante :
\begin{terminal}
\prompt\ \shcmd{history}
\end{terminal}

Les lignes commençant par le symbole \texttt{\#} sont des commentaires.
Elles servent à expliquer ou documenter des commandes, mais ne sont pas exécutées
par le shell.

\bigskip


% --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---

\section{Premiers pas}

\rsubsection{}
Certaines commandes sont intégrées directement dans le shell
(commandes internes ou \textit{built-in}),
tandis que d'autres sont des programmes externes.

La commande \texttt{type} permet de savoir de quel type est une commande.
Par exemple :
\begin{terminal}
\prompt\ \shcmd{type} \shcmd{cd}
\end{terminal}

\begin{warningbox}
Selon le système et la version du shell, certaines commandes peuvent exister
à la fois comme commande interne et comme programme externe.
Le résultat de \texttt{type} peut donc varier.
\end{warningbox}

À l'aide de cette commande, déterminez si les commandes suivantes sont
des commandes internes ou des commandes externes :
\begin{itemize}
    \item \texttt{cd}
    \item \texttt{echo}
    \item \texttt{ls}
    \item \texttt{pwd}
    \item \texttt{type}
    \item \texttt{mkdir}
    \item \texttt{date}
    \item \texttt{sleep}
    \item \texttt{touch}
    \item \texttt{cat}
    \item \texttt{grep}
\end{itemize}

% ---

\rsubsection{}
Savoir se documenter est une compétence essentielle sous Linux.
La documentation permet de comprendre le fonctionnement d'une commande
et de découvrir ses options.

La commande \texttt{man} fournit une page de manuel concise et standard pour les
commandes externes, tandis que la commande \texttt{info} propose une documentation
plus détaillée, organisée comme un ensemble de chapitres.
La commande \texttt{help} affiche une aide intégrée au shell et s'applique
principalement aux commandes internes.

\begin{enumerate}
    \item Consultez la documentation de la commande \texttt{ls} avec \texttt{man}, puis
          avec \texttt{info}.
          Pour quitter ces interfaces, appuyez sur \texttt{q}.
    \item Trouvez l'option permettant d'afficher les fichiers cachés, puis utilisez-la
          pour identifier les fichiers cachés présents dans votre répertoire personnel.
    \item Expliquez pourquoi la commande \texttt{man cd} ne fonctionne pas. Consultez 
          l'aide de la commande \texttt{cd}.
\end{enumerate}

\subsection*{Commandes utiles}

\begin{terminal}
\prompt\ \shcmd{man} \shcmd{ls}

\prompt\ \shcmd{info} \shcmd{ls}

\prompt\ \shcmd{ls} -a \$HOME 

\prompt\ \shcmd{ls} -a \textasciitilde \,\,
\tcomment{commande équivalente à la commande précédente}

\prompt\ \shcmd{help} \shcmd{cd}
\end{terminal}

% ---

\rsubsection{}
Pour installer un nouveau programme sous Linux, il est recommandé de commencer
par mettre à jour la liste des paquets disponibles avec \texttt{apt update}.
Cela permet au système de connaître les versions les plus récentes des logiciels.
\begin{terminal}
\prompt\ \tcomment{pour Linux :}

\prompt\ \shcmd{sudo apt update}
\end{terminal}

La commande \texttt{sudo} permet d'exécuter une commande avec les droits
d'administrateur.
Elle est nécessaire pour installer des programmes ou modifier le système.
Lors de son utilisation, un mot de passe peut être demandé.

\begin{warningbox}
Utilisez \texttt{sudo} uniquement lorsque cela est nécessaire et
vérifiez toujours la commande avant de l'exécuter.
\end{warningbox}

Ensuite, on installe le programme souhaité à l'aide de la commande
\texttt{apt install}.

Par exemple, installez puis lancez le programme \texttt{sl} :
\begin{terminal}
\prompt\ \tcomment{pour macOS :}

\prompt\ \shcmd{brew install sl}

\prompt\ \tcomment{pour Linux :}

\prompt\ \shcmd{sudo apt install sl}

\prompt\ \shcmd{sl}
\end{terminal}

Installez maintenant le programme \texttt{cowsay},
qui affiche un message sous forme de dessin ASCII :
\begin{terminal}
\prompt\ \tcomment{pour macOS :}

\prompt\ \shcmd{brew install cowsay}

\prompt\ \tcomment{pour Linux :}

\prompt\ \shcmd{sudo apt install cowsay}
\end{terminal}

Puis lancez-le avec un message de votre choix :
\begin{terminal}
\prompt\ \shcmd{cowsay} "Bonjour Linux"

\prompt\ \shcmd{cowsay} -f dragon "Je suis un dragon!"

\prompt\ \shcmd{cowsay} -f tux "Je suis Linux!"

\prompt\ \shcmd{cowsay} -f moose "Je suis un élan!"

\prompt\ \shcmd{cowsay} -f koala "Je suis un koala!"

\prompt\ \shcmd{cowthink} "Je pense donc je suis"
\end{terminal}

% ---

\rsubsection{}
Dans cet exercice, vous allez créer une petite arborescence afin de comprendre
l'effet des chemins relatifs et absolus.
Après chaque changement de répertoire avec la commande \texttt{cd},
affichez systématiquement le répertoire courant à l'aide de la commande \texttt{pwd}.

\begin{warningbox}
Il est fortement recommandé d'éviter les espaces dans les noms de fichiers
et de répertoires sous Linux.
Les espaces compliquent l'utilisation des commandes dans le terminal.

Préférez l'utilisation du caractère \texttt{-} (tiret) ou \texttt{\_} (underscore)
pour séparer les mots.
\end{warningbox}

\textit{Rappel :}
\begin{itemize}
    \item \texttt{.} désigne le répertoire courant ;
    \item \texttt{..} désigne le répertoire parent.
\end{itemize}

\begin{enumerate}
    \item Allez dans votre répertoire personnel.
\begin{terminal}
\prompt\ \tcomment{ces commandes sont équivalentes}

\prompt\ \shcmd{cd}

\prompt\ \shcmd{cd} \$HOME

\prompt\ \shcmd{cd} \$HOME/

\prompt\ \shcmd{cd} \$HOME/.

\prompt\ \shcmd{cd} \textasciitilde

\prompt\ \shcmd{cd} \textasciitilde/

\prompt\ \shcmd{cd} \textasciitilde/.
\end{terminal}
    \item Créez un répertoire nommé \texttt{TD1}.
\begin{terminal}
\prompt\ \shcmd{mkdir} TD1
\end{terminal}
    \item Entrez dans \texttt{TD1} et vérifiez votre position.
\begin{terminal}
\prompt\ \shcmd{cd} TD1

\prompt\ \shcmd{pwd}
\end{terminal}
    \item Créez un répertoire \texttt{TD1-bis} et placez-vous dedans.
    \item Créez les répertoires suivants :
    \begin{itemize}
        \item \texttt{TD1-bis-1}
        \item \texttt{TD1-bis-2}
        \item \texttt{TD1-bis-3}
    \end{itemize}
    \item Entrez dans \texttt{TD1-bis-1} et créez un répertoire nommé \texttt{test}.
    \item Revenez en arrière puis entrez dans \texttt{TD1-bis-3}.
\begin{terminal}
\prompt\ \tcomment{revenir en arrière}

\prompt\ \shcmd{cd} ..

\prompt\ \tcomment{ces deux commandes sont optionnelles}

\prompt\ \shcmd{pwd}

\prompt\ \shcmd{ls}

\prompt\ \shcmd{cd} TD1-bis-3
\end{terminal}
    \item Depuis \texttt{TD1-bis-3}, créez un répertoire nommé \texttt{test}
    à l'intérieur de \texttt{TD1-bis-2}, sans vous déplacer dans ce dernier.
\begin{terminal}
\prompt\ \shcmd{mkdir} ../TD1-bis-2/test
\end{terminal}
    \item Revenez dans votre répertoire personnel et affichez l'arborescence 
    complète du répertoire \texttt{TD1}.
\begin{terminal}
\prompt\ \shcmd{cd}

\prompt\ \shcmd{tree} TD1
\end{terminal}
Si la commande \texttt{tree} n'est pas disponible, installez-la :
\begin{terminal}
\prompt\ \tcomment{pour macOS :}

\prompt\ \shcmd{brew install tree}

\prompt\ \tcomment{pour Linux :}

\prompt\ \shcmd{sudo apt update}

\prompt\ \shcmd{sudo apt install tree}
\end{terminal}
    \item Supprimez ensuite tous les répertoires dont le nom commence par
    \texttt{TD1-bis-} en une ou plusieurs commandes.
\begin{terminal}
\prompt\ \shcmd{rm} -r TD1/TD1-bis/TD1-bis-1

\prompt\ \shcmd{rm} -r TD1/TD1-bis/TD1-bis-2

\prompt\ \shcmd{rm} -r TD1/TD1-bis/TD1-bis-3

\prompt\ \tcomment{ou bien}

\prompt\ \shcmd{rm} -r TD1/TD1-bis/TD1-bis-*
\end{terminal}
\end{enumerate}

\begin{warningbox}
La commande \texttt{rm} supprime définitivement des fichiers et des répertoires.
Utilisez-la avec précaution et vérifiez toujours le chemin avant de l'exécuter.
\end{warningbox}

% ---

\rsubsection{}
Dans cet exercice, vous allez créer un fichier texte et y écrire plusieurs lignes.

\begin{enumerate}
    \item Placez-vous dans le répertoire \texttt{TD1} et créez un fichier 
          nommé \texttt{notes.txt}.
\begin{terminal}
\prompt\ \shcmd{cd} \$HOME/TD1

\prompt\ \shcmd{touch} notes.txt
\end{terminal}
    \item Écrivez une première ligne dans le fichier.
\begin{terminal}
\prompt\ \shcmd{echo} "Le bonheur est parfois caché dans l'invisible." > notes.txt
\end{terminal}
    \item Ajoutez deux lignes supplémentaires sans effacer les précédentes.
\begin{terminal}
\prompt\ \shcmd{echo} "Rire, c'est vivre deux fois." >> notes.txt

\prompt\ \shcmd{echo} "Après la pluie, le beau temps." >> notes.txt
\end{terminal}
    \item Affichez le contenu du fichier.
\begin{terminal}
\prompt\ \shcmd{cat} notes.txt
\end{terminal}
    \item Ouvrez maintenant le fichier \texttt{notes.txt} avec un éditeur de texte
    (par exemple \texttt{gedit}, \texttt{nano}, \texttt{code}, etc.).
\begin{terminal}
\prompt\ \shcmd{gedit} notes.txt
\end{terminal}
    \item Dans la fenêtre de l'éditeur, ajoutez les lignes suivantes à la fin du fichier :
\begin{quote}
La nuit porte conseil. \\
Petit à petit, l'oiseau fait son nid.
\end{quote}
Enregistrez le fichier puis fermez l'éditeur.
    \item Affichez le contenu du fichier pour vérifier que toutes les lignes ont bien été ajoutées.
\begin{terminal}
\prompt\ \shcmd{cat} notes.txt
\end{terminal}
    \item Affichez le nombre de lignes du fichier \texttt{notes.txt}.
\begin{terminal}
\prompt\ \shcmd{wc} -l notes.txt
\end{terminal}
\end{enumerate}

% --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---

\section{Informations système}

Linux permet d'obtenir rapidement des informations sur la machine
(processeur, mémoire, etc.) ainsi que sur le système.

\rsubsection{} 
Déterminez les informations suivantes à l'aide de commandes Linux :
\begin{itemize}
    \item Nom de la machine
    \item Nom de l'utilisateur courant
    \item Système d'exploitation (distribution Linux le cas échéant)
    \item Version du noyau Linux
    \item Architecture du processeur (ex. \texttt{x86\_64}, \texttt{aarch64})
\end{itemize}

\subsection*{Commandes utiles}

\begin{terminal}
\prompt\ \shcmd{hostname}

\prompt\ \shcmd{whoami}

\prompt\ \shcmd{uname} -a

\prompt\ \shcmd{uname} -m

\prompt\ \shcmd{uname} -s

\prompt\ \shcmd{lsb\_release} -a \tcomment{Linux uniquement}
\end{terminal}

% ---

\rsubsection{}
Le processeur (CPU) est l'un des éléments centraux d'une machine.
\begin{enumerate}
    \item Combien de processeurs logiques possède votre machine ?
    \item Quel est le modèle du processeur ?
    \item Comparez vos résultats avec un autre étudiant.
\end{enumerate}

\subsection*{Commandes utiles}

\begin{terminal}
\prompt\ \shcmd{lscpu} \tcomment{pour macOS :} \shcmd{sysctl} -a \shcmd{|} \shcmd{grep} machdep.cpu

\prompt\ \shcmd{nproc}
\end{terminal}

% ---

\rsubsection{}
La mémoire vive est utilisée pour exécuter les programmes en cours.

\begin{enumerate}
    \item Quelle est la quantité totale de mémoire vive ?
    \item Quelle quantité est actuellement utilisée ?
\end{enumerate}

\subsection*{Commandes utiles}

\begin{terminal}
\prompt\ \shcmd{free} -h \tcomment{pour macOS :} \shcmd{vm\_stat}
\end{terminal}

% ---

\rsubsection{} 
Le programme \texttt{neofetch} permet d'afficher un résumé visuel des informations système.
Installez-le à l'aide des commandes suivantes :
\begin{terminal}
\prompt\ \tcomment{pour macOS :}

\prompt\ \shcmd{brew install neofetch}

\prompt\ \tcomment{pour Linux :}

\prompt\ \shcmd{sudo apt update}

\prompt\ \shcmd{sudo apt install neofetch}
\end{terminal}

Puis lancez-le :
\begin{terminal}
\prompt\ \shcmd{neofetch}
\end{terminal}
et comparez les informations affichées avec celles que vous avez obtenues
à l'aide des commandes précédentes.

% ---

\rsubsection{}
Linux organise les disques de stockage à l'aide de points de montage.

\begin{enumerate}
    \item Quelle est la taille de l'espace disque contenant votre répertoire personnel ?
    \item Combien d'espace est actuellement disponible ?
    \item Quelle est la taille de votre répertoire personnel ?
\end{enumerate}

\subsection*{Commandes utiles}

\begin{terminal}
\prompt\ \shcmd{df} -h \textasciitilde

\prompt\ \shcmd{du} -h {-}{-}max-depth=1 \textasciitilde

\prompt\ \tcomment{ou bien :}

\prompt\ \shcmd{du} -h -d 1 \textasciitilde
\end{terminal}

% --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---

\section{Variables en Bash}

Dans cette section, nous allons introduire la notion de variable en Bash et apprendre
à manipuler des données simples à l'aide du terminal.

\begin{warningbox}
En Bash, les espaces peuvent être significatifs selon le contexte.
Par exemple, il ne doit pas y avoir d'espace autour du symbole \texttt{=}
lors de la définition d'une variable.
\end{warningbox}

\begin{warningbox}
Le shell Bash est sensible à la casse (majuscules/minuscules).
Les variables \texttt{prenom}, \texttt{Prenom} et \texttt{PRENOM}
sont considérées comme différentes.
\end{warningbox}

\begin{warningbox}
En Bash, une variable ne possède pas de type.
C'est le contexte (arithmétique ou textuel) qui détermine la façon
dont sa valeur est interprétée.
\end{warningbox}

\rsubsection{Manipulation de chaînes de caractères}

\begin{itemize}
    \item Définissez une variable \texttt{prenom} contenant votre prénom.

    \item Comparez les commandes suivantes et expliquez la différence :
    \begin{terminal}
    \prompt\ \shcmd{echo} prenom
    
    \prompt\ \shcmd{echo} \$prenom

    \prompt\ \shcmd{echo} \$Prenom
    \end{terminal}

    \item Définissez une variable \texttt{nom} contenant votre nom de famille.

    \item Affichez une phrase contenant votre prénom et votre nom
          sur une seule ligne.
    \begin{terminal}
    \prompt\ \shcmd{echo} "Je m'appelle \$prenom \$nom"
    \end{terminal}

    \item Comparez les résultats des commandes suivantes :
    \begin{terminal}
    \prompt\ \shcmd{echo} "Je suis \$prenom"
    
    \prompt\ \shcmd{echo} 'Je suis \$prenom'
    \end{terminal}
\end{itemize}

% ---

\rsubsection{Manipulation de variables entières}

\begin{warningbox}
En Bash, les opérateurs \texttt{-gt}, \texttt{-lt}, \texttt{-eq} permettent de comparer
des entiers.
Les symboles \texttt{>}, \texttt{<} et \texttt{=} ont une signification différente
et ne doivent pas être utilisés pour les comparaisons numériques.
\end{warningbox}

\begin{itemize}
    \item Définissez une variable \texttt{a} contenant la valeur 5
          et une variable \texttt{b} contenant la valeur 3.

    \item Affichez le contenu des variables \texttt{a} et \texttt{b}.

    \item Essayez d'afficher la somme de \texttt{a} et \texttt{b} avec la commande suivante :
    \begin{terminal}
    \prompt\ \shcmd{echo} \$a + \$b
    \end{terminal}

    \item Calculez la somme de \texttt{a} et \texttt{b} à l'aide de la syntaxe arithmétique
          de Bash et stockez le résultat dans une variable \texttt{somme}.
    \begin{terminal}
    \prompt\ somme=\$((a + b))
    \end{terminal}

    \item Affichez la valeur de la variable \texttt{somme}.
    \begin{terminal}
    \prompt\ \shcmd{echo} "somme = \$somme"
    \end{terminal}

    \item Modifiez la valeur de la variable \texttt{a} en lui ajoutant 1.
    \begin{terminal}
    \prompt\ \shcmd{a=}\$((a + 1))
    \end{terminal}

    \item Calculez le produit de \texttt{a} et \texttt{b} et stockez le résultat
          dans une variable \texttt{produit}.

    \item Les commandes de test \texttt{[ ... ]} ne produisent pas de sortie.
          Elles indiquent le résultat d'un test uniquement à l'aide de leur code de retour,
          accessible via la variable \texttt{\$?}.
          Comparez les comportements obtenus et expliquez la différence.
    \begin{terminal}
    \prompt\ \shcmd{[} \$a < \$b \shcmd{]}

    \prompt\ \shcmd{echo} \$?
    \end{terminal}

    \begin{terminal}
    \prompt\ \shcmd{[} \$a -lt \$b \shcmd{]}

    \prompt\ \shcmd{echo} \$?
    \end{terminal}
\end{itemize}

% --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---

\end{document}
