\documentclass[11pt,a4paper]{article}

\usepackage[T1]{fontenc}
\usepackage[french]{babel}
\usepackage{geometry}

\usepackage{../../ldsstyle}

\geometry{margin=2.5cm}

\title{TD3 -- Langages de script}
\author{Abdallah Ammar}
\date{\today}

\begin{document}
\maketitle









% --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---





\section{Premier script Bash}

L'objectif de cette question est de découvrir la création et l'exécution d'un script Bash simple.

\begin{enumerate}

    \item Créez un répertoire nommé \texttt{TD3} dans votre répertoire personnel (\texttt{\$HOME}).
    \begin{terminal}
    \prompt\ \tcomment{d'abord, placez-vous dans votre répertoire personnel}

    \prompt\ \shcmd{cd} \$HOME

    \prompt\

    \prompt\ \tcomment{ensuite, on crée le répertoire TD3}

    \prompt\ \shcmd{mkdir} TD3

    \prompt\

    \prompt\ \tcomment{optionnel :}

    \prompt\ \shcmd{pwd}

    \prompt\ \shcmd{ls}
    \end{terminal}

    % ---

    \item Placez-vous dans le répertoire \texttt{TD3} et créez un sous-répertoire nommé \texttt{Q1}.
    \begin{terminal}
    \prompt\ \tcomment{pour aller dans TD3}

    \prompt\ \shcmd{cd} TD3

    \prompt\ \tcomment{ou bien :}

    \prompt\ \shcmd{cd} \$HOME/TD3

    \prompt\ \tcomment{ou bien :}

    \prompt\ \shcmd{cd} \textasciitilde/TD3

    \prompt\

    \prompt\ \shcmd{mkdir} Q1

    \prompt\

    \prompt\ \tcomment{optionnel :}

    \prompt\ \shcmd{pwd}

    \prompt\ \shcmd{ls}
    \end{terminal}

    % ---

    \item Placez-vous dans le répertoire \texttt{Q1} et créez un fichier nommé \texttt{hello.sh}.
    \begin{terminal}
    \prompt\ \tcomment{pour aller dans Q1}

    \prompt\ \shcmd{cd} Q1

    \prompt\ \tcomment{ou bien :}

    \prompt\ \shcmd{cd} \$HOME/TD3/Q1

    \prompt\ \tcomment{ou bien :}

    \prompt\ \shcmd{cd} \textasciitilde/TD3/Q1

    \prompt\

    \prompt\ \tcomment{pour créer le fichier :}

    \prompt\ \shcmd{touch} hello.sh

    \prompt\

    \prompt\ \tcomment{optionnel :}

    \prompt\ \shcmd{pwd}

    \prompt\ \shcmd{ls}
    \end{terminal}

    \begin{infobox}
    Sous Linux, un nom de fichier peut contenir des lettres, des chiffres, des points (\texttt{.}), des tirets (\texttt{-})
    et des underscores (\texttt{\_}).  
    Il est fortement déconseillé d'utiliser des espaces ou des caractères spéciaux dans les noms de fichiers.
    \end{infobox}

    \begin{infobox}
    Ajouter une extension aux fichiers, comme \texttt{.sh} dans \texttt{hello.sh}, est optionnel sous Linux.
    Cependant, c'est une bonne pratique : cela facilite la lecture et permet aux éditeurs de texte
    de colorer la syntaxe.
    \end{infobox}

    % ---

    \item Éditez le fichier \texttt{hello.sh} afin qu'il affiche \texttt{Hello World} à l'écran,
    en y ajoutant les lignes suivantes :
\begin{minted}{bash}
echo "Hello World";
echo "Ceci est mon premier script, mais certainement pas le dernier ;)";
\end{minted}

    \begin{infobox}
    Le point-virgule \texttt{;} est optionnel ici car chaque commande est sur une ligne distincte,
    mais il permet de séparer plusieurs commandes sur une même ligne.
    \end{infobox}

    \textit{Rappel :}
    On peut lancer un éditeur de texte (\texttt{gedit}, \texttt{nano}, etc.) avec :
    \begin{terminal}
    \prompt\ \tcomment{pour utiliser gedit :}

    \prompt\ \shcmd{gedit} hello.sh \&

    \prompt\ \tcomment{pour utiliser nano :}

    \prompt\ \shcmd{nano} hello.sh
    \end{terminal}

    \begin{infobox}
    L'utilisation de \texttt{\&} permet de lancer le programme en arrière-plan
    et de conserver le contrôle du terminal.
    Le shell crée alors un processus fils pour exécuter la commande.
    \end{infobox}

    % ---

    \item Exécutez le script en utilisant la commande \texttt{bash}.
    \begin{terminal}
    \prompt\ \shcmd{bash} hello.sh
    \end{terminal}

    % ---

    \item Modifiez le fichier \texttt{hello.sh} pour ajouter une ligne de \textit{shebang}
    en début de fichier :
\begin{minted}{bash}
#!/usr/bin/env bash

echo "Hello World"
echo "Ceci est mon premier script, mais certainement pas le dernier ;)"
\end{minted}

    \begin{infobox}
    Le shebang \texttt{\#!/usr/bin/env bash} indique au système quel interpréteur doit être utilisé
    pour exécuter le script.

    Sans cette ligne, lorsque l'on tente d'exécuter le fichier avec \texttt{./hello.sh},
    le système essaie de l'exécuter comme un programme binaire, ce qui échoue car il s'agit
    d'un script texte.

    Il est également possible d'utiliser \texttt{\#!/bin/bash}. Cependant, avec
    \texttt{\#!/usr/bin/env bash}, le système utilise la commande \texttt{env} pour rechercher
    automatiquement l'interpréteur \texttt{bash} dans les chemins définis par la variable
    \texttt{PATH}, ce qui rend le script plus portable d'un système à un autre.
    \end{infobox}

    % ---

    \item Si on inspecte les droits du fichier avec :
    \begin{terminal}
    \prompt\ \shcmd{ls} -l hello.sh
    \end{terminal}
    on constate qu'il n'est pas exécutable par défaut (\texttt{-rw-rw-r--}).
    Pour le rendre exécutable (\texttt{-rwxrwxr-x}), on utilise :
    \begin{terminal}
    \prompt\ \shcmd{chmod} +x hello.sh
    \end{terminal}

    \begin{infobox}
    Les droits d'un fichier sont définis par :
    \begin{itemize}
        \item \texttt{r} : droit de lecture (read)
        \item \texttt{w} : droit d'écriture (write)
        \item \texttt{x} : droit d'exécution (execute)
    \end{itemize}
    Ces droits sont définis pour le propriétaire du fichier, le groupe et les autres utilisateurs.
    \end{infobox}

    % ---

    \item Exécutez le script directement, sans utiliser la commande \texttt{bash}.
    \begin{terminal}
    \prompt\ \tcomment{avec un chemin relatif :}

    \prompt\ ./hello.sh

    \prompt\ \tcomment{avec un chemin absolu :}

    \prompt\ \$HOME/TD3/Q1/hello.sh
    \end{terminal}

    % ---

    \item Essayez de l'exécuter sans préciser de chemin :
    \begin{terminal}
    \prompt\ hello.sh
    \end{terminal}

    \begin{infobox}
    Cette commande ne fonctionne pas car le répertoire courant n'est pas inclus
    dans la variable d'environnement \texttt{PATH}.
    Contrairement à des commandes comme \texttt{ls} ou \texttt{pwd},
    le shell ne sait pas où chercher \texttt{hello.sh}.
    \end{infobox}

    % ---

    \item Modifiez le script pour définir une variable nommée \texttt{PRENOM}
    contenant votre prénom, et affichez le message :
\begin{minted}{bash}
#!/usr/bin/env bash

PRENOM="Toto"
echo "Coucou ${PRENOM}"
\end{minted}

    \begin{infobox}
    Il est recommandé d'utiliser \texttt{\{\}} autour des variables afin d'éviter
    toute ambiguïté lors de l'expansion.
    \end{infobox}

    % ---

    \item Ajoutez une dernière ligne au script afin de terminer son exécution avec 
          un code de retour indiquant que tout s'est bien déroulé.
          Testez ensuite le script, puis affichez son code de retour (\texttt{echo \$?}).
\begin{minted}{bash}
exit 0
\end{minted}

    \begin{infobox}
    La commande \texttt{exit} permet de terminer l'exécution du script.
    Un code de retour différent de \texttt{0} (par exemple, \texttt{exit 1}) indique une erreur.
    \end{infobox}

    % ---
    
    \item Modifiez le script afin de lire le prénom lors de l'exécution à l'aide de la commande \texttt{read}.
\begin{minted}{bash}
#!/usr/bin/env bash

read -p "Entrez votre prénom : " PRENOM
echo "Coucou ${PRENOM}"
\end{minted}

    \begin{infobox}
    La commande \texttt{read} peut afficher un message à l'utilisateur avant de lire l'entrée 
    grâce à l'option \texttt{-p}.
    Cela permet de rendre le script plus interactif et plus lisible.
    \end{infobox}

    % ---

    % ---

    \item Modifiez le script afin d'afficher le prénom saisi entièrement en majuscules.
\begin{minted}{bash}
echo "Coucou ${PRENOM^^}"
\end{minted}

    \begin{infobox}
    Bash permet de modifier la casse d'une chaîne de caractères.
    La syntaxe \texttt{\$\{VAR\^{}\^{}\}} convertit le contenu de \texttt{VAR} en majuscules,
    tandis que \texttt{\$\{VAR,,\}} le convertit en minuscules.
    cette syntaxe n'est disponible qu'à partir de \texttt{Bash 4.0}.
    \end{infobox}

    % ---

    \item Modifiez le script afin d'afficher le nombre de lettres contenues dans la variable \texttt{PRENOM}.
\begin{minted}{bash}
#!/usr/bin/env bash

read -p "Entrez votre prénom : " PRENOM
echo "Coucou ${PRENOM}"

NB_LETTRES=${#PRENOM}
echo "Votre prénom est composé de ${NB_LETTRES} lettres"
\end{minted}

    \begin{infobox}
    En bash, la syntaxe \texttt{\$\{\#VAR\}} permet d'obtenir la longueur de la chaîne de caractères
    contenue dans la variable \texttt{VAR}.
    \end{infobox}

    % ---

    \item Modifiez le script pour afficher certaines lettres du prénom à l'aide de la manipulation de chaînes :
    \begin{itemize}
        \item la première lettre de \texttt{PRENOM}
        \item la deuxième lettre de \texttt{PRENOM}
        \item la troisième lettre de \texttt{PRENOM}
        \item les trois premières lettres de \texttt{PRENOM}
        \item la dernière lettre de \texttt{PRENOM}
    \end{itemize}
\begin{minted}{bash}
echo "la première lettre de ${PRENOM} est ${PRENOM:0:1}"
echo "la deuxième lettre de ${PRENOM} est ${PRENOM:1:1}"
echo "la troisième lettre de ${PRENOM} est ${PRENOM:2:1}"
echo "les trois premières lettres de ${PRENOM} sont ${PRENOM:0:3}"
echo "la dernière lettre de ${PRENOM} est ${PRENOM:(-1):1}"
\end{minted}

    \begin{infobox}
    En bash, la syntaxe \texttt{\$\{VAR:position:longueur\}} permet d'extraire une sous-chaîne.
    La position commence à \texttt{0}. Si \texttt{longueur} n'est pas spécifiée, sa valeur par 
    défaut est \texttt{1}.
    \end{infobox}

    % ---

    \item Modifiez le script afin que le prénom soit fourni comme argument
          lors de l'exécution du script.
          Par exemple, l'appel du script devrait ressembler à ceci :
    \begin{terminal}
    \prompt\ ./hello.sh Toto
    \end{terminal}
\begin{minted}{bash}
#!/usr/bin/env bash

PRENOM=$1
echo "Coucou ${PRENOM}"
\end{minted}

    \begin{infobox}
    Lors de l'exécution d'un script Bash, certaines variables spéciales sont définies automatiquement.

    \texttt{\$0} contient le nom du script tel qu'il a été utilisé pour le lancer.

    \texttt{\$1}, \texttt{\$2}, \ldots \, correspondent aux arguments passés au script :
    \texttt{\$1} est le premier argument, \texttt{\$2} le second, etc.
    \end{infobox}

    % ---

    \item Modifiez le script afin de demander également l'âge de l'utilisateur,
    puis affichez un message prenant en compte cet âge.

\begin{minted}{bash}
#!/usr/bin/env bash

AGE=$2
echo "J'espère que ton ${AGE}e anniversaire s'est bien passé !"
\end{minted}

    % ---

    \item Modifiez le script afin de vérifier que le nombre de paramètres passés en ligne de commande
         est exactement égal à \texttt{2}.
         Si ce n'est pas le cas, affichez un message d'erreur puis quittez le script.
\begin{minted}{bash}
if [[ $# -ne 2 ]]; then
    echo "Erreur : le script attend exactement 2 paramètres."
    exit 1
fi
\end{minted}

    \begin{infobox}
    La variable spéciale \texttt{\$\#} contient le nombre de paramètres passés au script.
    \end{infobox}

    % ---

    \item Modifiez le script afin d'afficher une phrase indiquant que le prochain anniversaire
    sera encore meilleur, en utilisant un calcul sur l'âge.
\begin{minted}{bash}
PROCHAIN_AGE=$((AGE + 1))
echo "Le ${PROCHAIN_AGE}e sera encore meilleur :)"
\end{minted}

    % ---

    \item Modifiez le script afin d'afficher le résultat à l'aide d'un stégosaure.
          Pour cela, utilisez la commande \texttt{cowsay -f stegosaurus} à la place de \texttt{echo}.
          Testez votre script pour vérifier que l'affichage est correct.

\end{enumerate}







% --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---





\section{Boucle \texttt{for}}

\begin{enumerate}

    \item Placez-vous dans le répertoire \texttt{\$HOME/TD3} et créez un sous-répertoire nommé \texttt{Q2}.

    % ---

    \item Placez-vous dans le répertoire \texttt{Q2} et créez un fichier nommé \texttt{boucle.sh}.

    % ---

    \item Modifiez le fichier \texttt{boucle.sh} pour ajouter une ligne de \textit{shebang},
    puis ajoutez une ligne qui affiche le message \texttt{"coucou"} à l'écran.
    Rendez ensuite le script exécutable et vérifiez son bon fonctionnement.

    % ---

    \item Créez une boucle \texttt{for} qui parcourt une liste de mots et affiche chaque mot à l'écran.
\begin{minted}{bash}
echo "voici quelques distributions Linux"
for i in Ubuntu Debian Fedora openSUSE; do
    echo $i
done
\end{minted}

    % ---

    \item Dans le fichier \texttt{boucle.sh}, créez une première boucle \texttt{for} en utilisant l'expansion d'accolades
    afin d'afficher les entiers de \texttt{1} à \texttt{10}.
\begin{minted}{bash}
for i in {1..10}; do
    echo $i
done
\end{minted}

    % ---

    \item Comparez le résultat des exercices précédents avec les structures suivantes et observez les différences
          dans les valeurs affichées :
\begin{minted}{bash}
for i in {01..10}; do
    echo $i
done
\end{minted}
    puis :
\begin{minted}{bash}
for i in {001..010}; do
    echo $i
done
\end{minted}

    \begin{infobox}
    Avec l'expansion d'accolades, bash conserve le nombre de chiffres utilisé dans les bornes.
    Cela permet de générer des suites avec des zéros en tête,
    ce qui est pratique pour nommer des fichiers de manière ordonnée.
    \end{infobox}

    % ---

    \item Modifiez la boucle précédente pour afficher les entiers de \texttt{10} à \texttt{-10} 
          avec un pas de \texttt{-2}.
\begin{minted}{bash}
for i in {10..-10..-2}; do
    echo $i
done
\end{minted}

    % ---

    \item Modifiez le code pour définir les valeurs de début et de fin à l'aide de variables.
          Qu'observez-vous ?
\begin{minted}{bash}
START=10
END=-10
for i in {$START..$END}; do
    echo $i
done
\end{minted}

    \begin{infobox}
    L'expansion d'accolades est effectuée avant l'expansion des variables.
    Elle ne peut donc pas utiliser de variables.
    \end{infobox}

    % ---

    \item Modifiez maintenant la boucle pour afficher les lettres de \texttt{a} à \texttt{h}.
\begin{minted}{bash}
for c in {a..h}; do
    echo $c
done
\end{minted}

    % ---

    \item Nous allons maintenant utiliser la syntaxe \texttt{(( ))}, basée sur une initialisation,
          une condition et une incrémentation.
          Créez une boucle qui affiche les entiers de \texttt{1} à \texttt{10} avec un pas de \texttt{1}.
\begin{minted}{bash}
for ((i=1; i<=10; i++)); do
    echo $i
done
\end{minted}

    \begin{infobox}
    En bash, les opérateurs de comparaison dépendent du contexte.

    Dans un test \texttt{[[ ... ]]}, on utilise \texttt{-eq}, \texttt{-lt}, \texttt{-gt} pour les comparaisons numériques.

    Dans une expression arithmétique \texttt{(( ... ))}, on utilise les opérateurs classiques
    \texttt{==}, \texttt{<}, \texttt{>} car bash manipule directement des entiers.
    \end{infobox}

    % ---

    \item Modifiez la boucle précédente afin d'afficher les entiers de \texttt{1} à \texttt{10} avec un pas de \texttt{2}.
\begin{minted}{bash}
for ((i=1; i<=10; i+=2)); do
    echo $i
done
\end{minted}

    % ---

    \item Modifiez votre script afin que la valeur initiale, la valeur finale et le pas de la boucle
    soient fournis par l'utilisateur via les arguments de la ligne de commande :
    \texttt{\$1} pour la valeur initiale, \texttt{\$2} pour la valeur finale et \texttt{\$3} pour le pas.
    Utilisez ensuite ces variables dans une boucle \texttt{for} avec la syntaxe \texttt{(( ))}.
\begin{minted}{bash}
START=$1
END=$2
STEP=$3

for ((i=START; i<=END; i+=STEP)); do
    echo $i
done
\end{minted}

    % ---

    \item À l'intérieur de la boucle \texttt{for}, ajoutez une condition \texttt{if} permettant d'indiquer
          si le nombre courant est pair ou impair.
\begin{minted}{bash}
if (( i % 2 == 0 )); then
    echo "$i est pair"
else
    echo "$i est impair"
fi
done
\end{minted}

    \begin{infobox}
    La structure
\begin{minted}{bash}
if [[ condition ]]; then
    commandes
fi
\end{minted}
    permet de tester une \texttt{condition} et, si elle est vraie, d'exécuter des \texttt{commandes}.
    En bash, il est recommandé d'utiliser \texttt{[[ ... ]]} pour les tests, même si \texttt{[ ... ]} reste possible.
    Pour tester plusieurs conditions, la syntaxe devient :
\begin{minted}{bash}
if [[ condition_1 ]]; then
    commandes_1
elif [[ condition_2 ]]; then
    commandes_2
elif [[ condition_3 ]]; then
    commandes_3
fi
\end{minted}
    \end{infobox}

    \begin{infobox}
    L'opérateur \texttt{\%} permet de calculer le reste de la division entière (modulo).
    \end{infobox}

\end{enumerate}










% --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---







\section{Jeu du nombre inconnu}

\begin{enumerate}

    \item Placez-vous dans le répertoire \texttt{TD3} et créez un sous-répertoire nommé \texttt{Q3}.

    % ---

    \item Placez-vous dans le répertoire \texttt{Q3} et créez un fichier nommé \texttt{game.sh}.

    % ---

    \item Modifiez le fichier \texttt{game.sh} pour ajouter une ligne de \textit{shebang}, puis rendez votre script exécutable.

    % ---

    \item Créez une variable \texttt{VAR\_RAND} et ajoutez une ligne pour l'afficher à l'écran.
    Amusez-vous à lancer le script 4 ou 5 fois.
\begin{minted}{bash}
VAR_RAND=$RANDOM
\end{minted}

    \begin{infobox}
    La variable spéciale \texttt{RANDOM} permet de générer des nombres pseudo-aléatoires compris entre 
    \texttt{0} et \texttt{32767}.
    \end{infobox}

    % ---

    \item Nous allons maintenant modifier la variable pour la normaliser entre \texttt{1} et \texttt{100}.
    Vérifiez le nouveau script en l'exécutant quelques fois.
\begin{minted}{bash}
VAR_RAND=$((VAR_RAND % 100 + 1))
\end{minted}

    % ---

    \item Ajoutez une ligne qui récupère une valeur entrée par l'utilisateur dans la 
          variable \texttt{GUESS} à l'aide de la commande \texttt{read}.

    % ---

    \item Modifiez le code pour tester si \texttt{GUESS} correspond au nombre aléatoire choisi ou non.
          Lancez le code plusieurs fois pour tester différents cas.
\begin{minted}{bash}
if [[ $GUESS -eq $VAR_RAND ]]; then
    echo "QUELLE CHANCE !!!!!!!!!!!"
else
    echo "Raté, essayez encore."
fi
\end{minted}

    % ---

    \item Créez une boucle \texttt{while} qui permet de proposer à l'utilisateur de faire plusieurs tentatives successives
    et de tester à chaque fois si \texttt{GUESS} correspond au nombre aléatoire.
    Pensez à utiliser \texttt{break} dans votre comparaison afin d'éviter une boucle infinie.
\begin{minted}{bash}
while true; do
    # TODO: récupérer une valeur GUESS
    # TODO: comparer avec VAR_RAND
done
\end{minted}

    \begin{infobox}
    La structure
\begin{minted}{bash}
while [[ condition ]]; do
    commandes
done
\end{minted}
    permet de créer une boucle qui s'exécute tant que la \texttt{condition} est vraie.

    Une autre manière courante de construire ce type de boucle est d'utiliser une condition toujours vraie,
    puis de sortir explicitement de la boucle avec \texttt{break} :
\begin{minted}{bash}
while true; do
    commandes
    if [[ condition_sortie ]]; then
        break
    fi
done
\end{minted}
    \end{infobox}

    % ---

    \item Améliorez le jeu en indiquant à l'utilisateur si le nombre proposé est supérieur ou inférieur au 
          nombre aléatoire.

    % ---

    \item Ajoutez un compteur \texttt{COUNT} qui permet de compter le nombre d'essais effectués par l'utilisateur.
          Incrémentez ce compteur à chaque nouvelle tentative et affichez sa valeur lorsque le bon nombre est trouvé.
          Si le nombre d'essais est inférieur ou égal à \texttt{3}, affichez également ce message "Bien joué !!".

\end{enumerate}




% --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---





\end{document}
