\documentclass[11pt,a4paper]{article}

\usepackage[T1]{fontenc}
\usepackage[french]{babel}
\usepackage{geometry}

\usepackage{../tdstyle}

\geometry{margin=2.5cm}

\title{TD2 -- Langages de script}
\author{Abdallah Ammar}
\date{\today}

\begin{document}
\maketitle



\begin{warningbox}
Il est fortement recommandé de taper les commandes à la main afin de se familiariser
avec le terminal.
\end{warningbox}


\begin{warningbox}
Avant de regarder les solutions proposées dans ce TD, prenez le temps de réfléchir
et de tenter de résoudre les questions par vous-même.
L'erreur fait partie du processus d'apprentissage.
\end{warningbox}



\bigskip




% --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---

\section{Globbing}

Le \textit{globbing} est un mécanisme du shell permettant de faire correspondre
des motifs (\textit{patterns}) à des noms de fichiers.

\begin{infobox}
Le globbing est effectué par le shell avant l'exécution de la commande.
Les caractères \texttt{*}, \texttt{?} et \texttt{[...]} ont une signification
spéciale et peuvent être désactivés à l'aide de guillemets ou d'un antislash.
\end{infobox}

\begin{itemize}
    \item Créez les fichiers suivants dans un répertoire de test :
    \begin{terminal}
    \prompt\ \shcmd{touch} a.txt b.txt c.txt aa.txt bb.txt cc.txt

    \prompt\ \shcmd{touch} a.java b.java c.java

    \prompt\ \shcmd{touch} ba.txt ab.txt ca.txt ac.txt

    \prompt\ \shcmd{touch} note.pdf image.png
    \end{terminal}

    % ---

    \item Exécutez les commandes suivantes :
    \begin{terminal}
    \prompt\ \shcmd{ls}

    \prompt\ \shcmd{ls} *.txt

    \prompt\ \shcmd{ls} *.java

    \prompt\ \shcmd{ls} *.png

    \prompt\ \shcmd{ls} *.pdf

    \prompt\ \shcmd{ls} *.*

    \prompt\ \shcmd{ls} *.TXT
    \end{terminal}
    Que remarquez-vous ?

    \begin{infobox}
    Le caractère \texttt{*} correspond à n'importe quelle suite de caractères
    (dans un nom de fichier).
    \end{infobox}

    % ---

    \item Exécutez les commandes suivantes :
    \begin{terminal}
    \prompt\ \shcmd{ls} ?.txt

    \prompt\ \shcmd{ls} a?.txt

    \prompt\ \shcmd{ls} A?.txt

    \prompt\ \shcmd{ls} ?c.txt

    \prompt\ \shcmd{ls} ??.txt

    \prompt\ \shcmd{ls} ???.txt
    \end{terminal}
    
    \begin{infobox}
    Le caractère \texttt{?} correspond exactement à un seul caractère.
    \end{infobox}

    % ---

    \item Exécutez les commandes suivantes :
    \begin{terminal}
    \prompt\ \shcmd{ls} [ab].txt

    \prompt\ \shcmd{ls} [ba].txt

    \prompt\ \shcmd{ls} [bc].txt

    \prompt\ \shcmd{ls} [ac].txt

    \prompt\ \shcmd{ls} a[bc].txt

    \prompt\ \shcmd{ls} [bc]a.txt

    \prompt\ \shcmd{ls} [abc][abc].txt
    \end{terminal}
    
    \begin{infobox}
    Les crochets \texttt{[ ]} permettent de rechercher un caractère parmi plusieurs possibilités.
    Par exemple, \texttt{[ab]} correspond à soit 'a' soit 'b'.
    \end{infobox}

    % ---

    \item Comparez les commandes suivantes :
    \begin{terminal}
    \prompt\ \shcmd{ls} *.txt

    \prompt\ \shcmd{ls} "*.txt"
    \end{terminal}
    
    \begin{infobox}
    Lorsque le motif est entouré de guillemets, le globbing n'est pas interprété
    par le shell.
    \end{infobox}

    \item Exécutez les commandes suivantes :
    \begin{terminal}
    \prompt\ \shcmd{ls} *

    \prompt\ \shcmd{ls} .*
    \end{terminal}

    \begin{infobox}
    Par défaut, le globbing ne correspond pas aux fichiers cachés
    (commençant par un point).
    \end{infobox}
\end{itemize}

% --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---

\section{Premier script Bash}

L'objectif de cette question est de découvrir la création et l'exécution d'un script Bash simple.

%\rsubsection{Hello World}

\begin{itemize}
    \item Créez un répertoire nommé \texttt{TD2} dans votre répertoire personnel (\texttt{\$HOME}).
    \begin{terminal}
    \prompt\ \tcomment{d'abord, on se place dans le répertoire HOME}

    \prompt\ \shcmd{cd} \$HOME

    \prompt\

    \prompt\ \tcomment{ensuite, on crée le répertoire TD2}

    \prompt\ \shcmd{mkdir} TD2

    \prompt\

    \prompt\ \tcomment{optionnel :}

    \prompt\ \shcmd{pwd}

    \prompt\ \shcmd{ls}
    \end{terminal}

    \item Placez-vous dans le répertoire \texttt{TD2} et créez un sous-répertoire nommé \texttt{Q1}.
    \begin{terminal}
    \prompt\ \tcomment{pour aller dans TD2}

    \prompt\ \shcmd{cd} TD2

    \prompt\ \tcomment{ou bien :}

    \prompt\ \shcmd{cd} \$HOME/TD2

    \prompt\

    \prompt\ \shcmd{mkdir} Q1

    \prompt\

    \prompt\ \tcomment{optionnel :}

    \prompt\ \shcmd{pwd}

    \prompt\ \shcmd{ls}
    \end{terminal}

    \item Placez-vous dans le répertoire \texttt{Q1} et créez un fichier nommé \texttt{hello.sh}.
    \begin{terminal}
    \prompt\ \tcomment{pour aller dans Q1}

    \prompt\ \shcmd{cd} Q1

    \prompt\ \tcomment{ou bien :}

    \prompt\ \shcmd{cd} \$HOME/TD2/Q1

    \prompt\

    \prompt\ \tcomment{pour créer le fichier :}

    \prompt\ \shcmd{touch} hello.sh

    \prompt\

    \prompt\ \tcomment{optionnel :}

    \prompt\ \shcmd{pwd}

    \prompt\ \shcmd{ls}
    \end{terminal}

    \begin{infobox}
    Ajouter une extension aux fichiers, comme \texttt{.sh} dans \texttt{hello.sh}, est optionnel sous Linux.
    Cependant, c'est une bonne pratique : cela facilite la lecture et permet aux éditeurs de texte
    de colorer la syntaxe.
    \end{infobox}

    \item Éditez le fichier \texttt{hello.sh} afin qu'il affiche \texttt{Hello World} à l'écran,
    en y ajoutant les lignes suivantes :
\begin{minted}{bash}
echo "Hello World";
echo "Ceci est mon premier script, mais certainement pas le dernier ;)";
\end{minted}

    \begin{infobox}
    Le point-virgule \texttt{;} est optionnel ici car chaque commande est sur une ligne distincte,
    mais il permet de séparer plusieurs commandes sur une même ligne.
    \end{infobox}

    \textit{Rappel :}  
    On peut lancer un éditeur de texte (\texttt{gedit}, \texttt{nano}, etc.) avec :
    \begin{terminal}
    \prompt\ \tcomment{pour utiliser gedit :}

    \prompt\ \shcmd{gedit} hello.sh \&

    \prompt\ \tcomment{pour utiliser nano :}

    \prompt\ \shcmd{nano} hello.sh \&
    \end{terminal}

    \begin{infobox}
    L'utilisation de \texttt{\&} permet de lancer le programme en arrière-plan
    et de conserver le contrôle du terminal.
    Le shell crée alors un processus fils pour exécuter la commande.
    \end{infobox}

    \item Exécutez le script en utilisant la commande \texttt{bash}.
    \begin{terminal}
    \prompt\ \shcmd{bash} hello.sh
    \end{terminal}

    \item Modifiez le fichier \texttt{hello.sh} pour ajouter une ligne de \textit{shebang}
    en début de fichier :
\begin{minted}{bash}
#!/usr/bin/env bash

echo "Hello World"
echo "Ceci est mon premier script, mais certainement pas le dernier ;)"
\end{minted}

    \begin{infobox}
    Le shebang \texttt{\#!/usr/bin/env bash} indique au système quel interpréteur doit être utilisé
    pour exécuter le script.
    
    Sans cette ligne, lorsque l'on tente d'exécuter le fichier avec \texttt{./hello.sh},
    le système essaie de l'exécuter comme un programme binaire, ce qui échoue car il s'agit
    d'un script texte.
    
    Il est également possible d'utiliser \texttt{\#!/bin/bash}. Cependant, avec
    \texttt{\#!/usr/bin/env bash}, le système utilise la commande \texttt{env} pour rechercher
    automatiquement l'interpréteur \texttt{bash} dans les chemins définis par la variable
    \texttt{PATH}, ce qui rend le script plus portable d'un système à un autre.
    \end{infobox}

    \item Si on inspecte les droits du fichier avec :
    \begin{terminal}
    \prompt\ \shcmd{ls} -l hello.sh
    \end{terminal}
    on constate qu'il n'est pas exécutable par défaut (\texttt{-rw-rw-r--}).
    Pour le rendre exécutable (\texttt{-rwxrwxr-x}), on utilise :
    \begin{terminal}
    \prompt\ \shcmd{chmod} +x hello.sh
    \end{terminal}

    \begin{infobox}
    Les droits d'un fichier sont définis par :
    \begin{itemize}
        \item \texttt{r} : droit de lecture (read)
        \item \texttt{w} : droit d'écriture (write)
        \item \texttt{x} : droit d'exécution (execute)
    \end{itemize}
    Ces droits sont définis pour le propriétaire du fichier, le groupe et les autres utilisateurs.
    \end{infobox}

    \item Exécutez le script directement, sans utiliser la commande \texttt{bash}.
    \begin{terminal}
    \prompt\ \tcomment{avec un chemin relatif :}

    \prompt\ ./hello.sh

    \prompt\ \tcomment{avec un chemin absolu :}

    \prompt\ \$HOME/TD2/Q1/hello.sh
    \end{terminal}

    \item Essayez de l'exécuter sans préciser de chemin :
    \begin{terminal}
    \prompt\ hello.sh
    \end{terminal}

    \begin{infobox}
    Cette commande ne fonctionne pas car le répertoire courant n'est pas inclus
    dans la variable d'environnement \texttt{PATH}.
    Contrairement à des commandes comme \texttt{ls} ou \texttt{pwd},
    le shell ne sait pas où chercher \texttt{hello.sh}.
    \end{infobox}

    \item Modifiez le script pour définir une variable nommée \texttt{prenom}
    contenant votre prénom, et affichez le message :
\begin{minted}{bash}
#!/usr/bin/env bash

prenom="Toto"

echo "Coucou ${prenom}"
\end{minted}

    \begin{infobox}
    Il est recommandé d'utiliser \texttt{\{\}} autour des variables afin d'éviter
    toute ambiguïté lors de l'expansion.
    \end{infobox}
    
    \item Modifiez le script afin de lire le prénom lors de l'exécution à l'aide de la commande \texttt{read}.
\begin{minted}{bash}
#!/usr/bin/env bash

echo "Entrez votre prénom :"
read prenom

echo "Coucou ${prenom}"
\end{minted}

    \item Modifiez le script afin que le prénom soit fourni comme argument
    lors de l'exécution du script.
\begin{minted}{bash}
#!/usr/bin/env bash

prenom=$1

echo "Coucou ${prenom}"
\end{minted}

    \begin{infobox}
    Lors de l'exécution d'un script Bash, certaines variables spéciales sont définies automatiquement.

    \texttt{\$0} contient le nom du script tel qu'il a été utilisé pour le lancer.

    \texttt{\$1}, \texttt{\$2}, \ldots \, correspondent aux arguments passés au script :
    \texttt{\$1} est le premier argument, \texttt{\$2} le second, etc.
    \end{infobox}

    \item Modifiez le script afin de demander également l'âge de l'utilisateur,
    puis affichez un message prenant en compte cet âge.

\begin{minted}{bash}
#!/usr/bin/env bash

prenom=$1
age=$2

echo "Coucou ${prenom}"
echo "J'espère que ton ${age}e anniversaire s'est bien passé !"
\end{minted}

    \item Modifiez le script afin d'afficher une phrase indiquant que le prochain anniversaire
    sera encore meilleur, en utilisant un calcul sur l'âge.
\begin{minted}{bash}
#!/usr/bin/env bash

prenom=$1
age=$2

echo "Coucou ${prenom}"
echo "J'espère que ton ${age}e anniversaire s'est bien passé !"

prochain_age=$((age + 1))
echo "Le ${prochain_age}e sera encore meilleur :)"
\end{minted}

    \item Modifiez le script afin de réaliser l'affichage à l'aide d'un stégosaure
    (en utilisant \texttt{cowsay}).
\begin{minted}{bash}
#!/usr/bin/env bash

prenom=$1
age=$2

cowsay -f stegosaurus "Coucou ${prenom}"
cowsay -f stegosaurus "J'espère que ton ${age}e anniversaire s'est bien passé !"

prochain_age=$((age + 1))
cowsay -f stegosaurus "Le ${prochain_age}e sera encore meilleur :)"
\end{minted}
\end{itemize}


% --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---

\section{Récupération des fichiers de données}
Dans ce TD, vous allez travailler sur des fichiers texte fournis par l'enseignant.
Ces fichiers contiennent des données fictives destinées à l'apprentissage
des commandes de filtrage et d'analyse de texte.

Commencez par créer un répertoire \texttt{data}, puis téléchargez les fichiers
à l'aide des commandes suivantes :

\begin{terminal}
\prompt\ \shcmd{mkdir} data

\prompt\ \shcmd{cd} data

\prompt\ \shcmd{wget} https://raw.githubusercontent.com/AbdAmmar/LDS/main/TD/TD2/data/users.txt

\prompt\ \shcmd{wget} https://raw.githubusercontent.com/AbdAmmar/LDS/main/TD/TD2/data/logs.txt

\prompt\ \shcmd{wget} https://raw.githubusercontent.com/AbdAmmar/LDS/main/TD/TD2/data/notes.txt
\end{terminal}

Vérifiez que les fichiers ont bien été téléchargés.
Si la commande \texttt{wget} n'est pas disponible, installez-la avec :

\begin{terminal}
\prompt\ \shcmd{sudo} apt update

\prompt\ \shcmd{sudo} apt install wget
\end{terminal}

% --------------------------------------------------
\section{Lire et compter}

\subsection*{Travail à faire}

\begin{enumerate}
    \item Affichez le contenu du fichier \texttt{users.txt}.
    \item Comptez le nombre de lignes du fichier.
    \item Affichez le contenu du fichier \texttt{logs.txt}.
    \item Comptez le nombre de lignes du fichier \texttt{notes.txt}.
\end{enumerate}

\subsection*{Commandes utiles}

\begin{terminal}
\prompt\ \shcmd{cat} users.txt

\prompt\ \shcmd{wc} \texttt{-l} users.txt
\end{terminal}

% --------------------------------------------------
\section{Introduction aux pipes}

Un \textit{pipe} permet d'envoyer la sortie d'une commande en entrée d'une autre.

\subsection*{Travail à faire}

\begin{enumerate}
    \item Comptez le nombre de lignes de \texttt{users.txt} sans afficher le contenu du fichier.
    \item Expliquez le rôle du symbole \texttt{|}.
\end{enumerate}

\subsection*{Commande clé}

\begin{terminal}
\prompt\ \shcmd{cat} users.txt \texttt{|} \shcmd{wc} \texttt{-l}
\end{terminal}

% --------------------------------------------------
\section{Rechercher des informations avec \texttt{grep}}

\subsection*{Travail à faire}

À partir du fichier \texttt{users.txt} :

\begin{enumerate}
    \item Affichez les lignes contenant \texttt{bash}.
    \item Comptez le nombre d'utilisateurs utilisant \texttt{bash}.
    \item Affichez les lignes ne contenant pas \texttt{bash}.
\end{enumerate}

\subsection*{Commandes utiles}

\begin{terminal}
\prompt\ \shcmd{grep} bash users.txt

\prompt\ \shcmd{grep} \texttt{-c} bash users.txt

\prompt\ \shcmd{grep} \texttt{-v} bash users.txt
\end{terminal}

% --------------------------------------------------
\section{Extraire des informations}

Le fichier \texttt{users.txt} est structuré : les champs sont séparés par le caractère \texttt{:}.

\subsection*{Travail à faire}

\begin{enumerate}
    \item Affichez uniquement la colonne des noms d'utilisateurs.
    \item Affichez uniquement la colonne des shells.
\end{enumerate}

\subsection*{Commandes utiles}

\begin{terminal}
\prompt\ \shcmd{cut} \texttt{-d: -f1} users.txt

\prompt\ \shcmd{cut} \texttt{-d: -f2} users.txt
\end{terminal}

% --------------------------------------------------
\section{Trier et compter}

\subsection*{Travail à faire}

\begin{enumerate}
    \item Affichez la liste des shells utilisés.
    \item Triez cette liste.
    \item Comptez combien de fois chaque shell apparaît.
\end{enumerate}

\subsection*{Pipeline attendu}

\begin{terminal}
\prompt\ \shcmd{cut} \texttt{-d: -f2} users.txt \texttt{|} \shcmd{sort} \texttt{|} \shcmd{uniq} \texttt{-c}
\end{terminal}

% --------------------------------------------------
\section{Analyse de fichiers de logs}

\subsection*{Travail à faire}

À partir du fichier \texttt{logs.txt} :

\begin{enumerate}
    \item Affichez uniquement les lignes contenant \texttt{ERROR}.
    \item Comptez le nombre d'erreurs.
    \item Affichez les noms des utilisateurs ayant généré une erreur.
\end{enumerate}

\subsection*{Commandes utiles}

\begin{terminal}
\prompt\ \shcmd{grep} ERROR logs.txt

\prompt\ \shcmd{grep} \texttt{-c} ERROR logs.txt

\prompt\ \shcmd{grep} ERROR logs.txt \texttt{|} \shcmd{cut} \texttt{-d= -f2}
\end{terminal}

% --------------------------------------------------
\section{Mini-analyse}

\subsection*{Travail à faire}

Sans utiliser d'éditeur de texte :

\begin{itemize}
    \item Quel est le shell le plus utilisé ?
    \item Quel utilisateur apparaît le plus souvent dans les logs ?
\end{itemize}

Justifiez vos réponses à l'aide de commandes Linux.




% --------------------------------------------------
\section{Les flux standards}

Ce TD a pour objectif d'introduire la gestion des sorties et des erreurs
sous Linux.
Sous Linux, un programme communique avec l'extérieur à l'aide de flux :
\begin{itemize}
    \item l'entrée standard (stdin) ;
    \item la sortie standard (stdout) ;
    \item la sortie d'erreur (stderr).
\end{itemize}

Par défaut, la sortie standard et la sortie d'erreur sont affichées à l'écran.

% --------------------------------------------------
\section{Rediriger la sortie standard}

\subsection*{Travail à faire}

\begin{enumerate}
    \item Listez le contenu de votre répertoire personnel.
    \item Redirigez cette sortie dans un fichier \texttt{liste.txt}.
    \item Vérifiez le contenu du fichier.
\end{enumerate}

\subsection*{Commandes}

\begin{terminal}
\prompt\ \shcmd{ls}

\prompt\ \shcmd{ls} \texttt{>} liste.txt

\prompt\ \shcmd{cat} liste.txt
\end{terminal}

% --------------------------------------------------
\section{Générer et observer une erreur}

\subsection*{Travail à faire}

\begin{enumerate}
    \item Essayez d'afficher un fichier qui n'existe pas.
    \item Observez le message affiché.
\end{enumerate}

\begin{terminal}
\prompt\ \shcmd{cat} fichier\_inexistant.txt
\end{terminal}

Expliquez pourquoi le message n'est pas redirigé avec \texttt{>}.

% --------------------------------------------------
\section{Rediriger la sortie d'erreur}

La sortie d'erreur peut être redirigée séparément.

\subsection*{Travail à faire}

\begin{enumerate}
    \item Redirigez l'erreur précédente dans un fichier \texttt{erreur.txt}.
    \item Vérifiez le contenu du fichier.
\end{enumerate}

\begin{terminal}
\prompt\ \shcmd{cat} fichier\_inexistant.txt \texttt{2>} erreur.txt

\prompt\ \shcmd{cat} erreur.txt
\end{terminal}

% --------------------------------------------------
\section{Rediriger sortie et erreur}

Il est possible de rediriger à la fois la sortie standard et la sortie d'erreur.

\subsection*{Travail à faire}

\begin{enumerate}
    \item Lancez une commande produisant à la fois une sortie et une erreur.
    \item Redirigez les deux flux dans un même fichier.
\end{enumerate}

\begin{terminal}
\prompt\ \shcmd{ls} fichier\_inexistant \texttt{>} sortie.txt \texttt{2>} erreur.txt
\end{terminal}

Ou en une seule commande :

\begin{terminal}
\prompt\ \shcmd{ls} fichier\_inexistant \texttt{>} tout.txt \texttt{2>\&1}
\end{terminal}

\end{document}
