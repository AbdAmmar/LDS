\documentclass[11pt,a4paper]{article}

\usepackage[T1]{fontenc}
\usepackage[french]{babel}
\usepackage{geometry}

\usepackage{../tdstyle}

\geometry{margin=2.5cm}

\title{TD2 -- Langages de script}
\author{Abdallah Ammar}
\date{\today}

\begin{document}
\maketitle



\begin{warningbox}
Il est fortement recommandé de taper les commandes à la main afin de se familiariser
avec le terminal.
\end{warningbox}


\begin{warningbox}
Avant de regarder les solutions proposées dans ce TD, prenez le temps de réfléchir
et de tenter de résoudre les questions par vous-même.
L'erreur fait partie du processus d'apprentissage.
\end{warningbox}



\bigskip




% --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---

\section{Globbing}

Le \textit{globbing} est un mécanisme du shell permettant de faire correspondre
des motifs (\textit{patterns}) à des noms de fichiers.

\begin{infobox}
Le globbing est effectué par le shell avant l'exécution de la commande.
Les caractères \texttt{*}, \texttt{?} et \texttt{[...]} ont une signification
particulière et peuvent être désactivés à l'aide de guillemets ou d'un antislash (\texttt{\textbackslash}).
\end{infobox}

\begin{itemize}
    \item Créez un répertoire nommé \texttt{TD2} dans votre répertoire personnel (\texttt{\$HOME}).
    \begin{terminal}
    \prompt\ \tcomment{d'abord, placez-vous dans votre répertoire personnel}

    \prompt\ \shcmd{cd} \$HOME

    \prompt\

    \prompt\ \tcomment{ensuite, on crée le répertoire TD2}

    \prompt\ \shcmd{mkdir} TD2

    \prompt\

    \prompt\ \tcomment{optionnel :}

    \prompt\ \shcmd{pwd}

    \prompt\ \shcmd{ls}
    \end{terminal}

    \item Placez-vous dans le répertoire \texttt{TD2} et créez un sous-répertoire nommé \texttt{Q1}.
    \begin{terminal}
    \prompt\ \tcomment{pour aller dans TD2}

    \prompt\ \shcmd{cd} TD2

    \prompt\ \tcomment{ou bien :}

    \prompt\ \shcmd{cd} \$HOME/TD2

    \prompt\

    \prompt\ \shcmd{mkdir} Q1

    \prompt\

    \prompt\ \tcomment{optionnel :}

    \prompt\ \shcmd{pwd}

    \prompt\ \shcmd{ls}
    \end{terminal}

    \item Placez-vous dans le répertoire \texttt{Q1} et créez les fichiers suivants :
    \begin{terminal}
    \prompt\ \shcmd{touch} a.txt b.txt c.txt aa.txt bb.txt cc.txt

    \prompt\ \shcmd{touch} a.java b.java c.java

    \prompt\ \shcmd{touch} ba.txt ab.txt ca.txt ac.txt

    \prompt\ \shcmd{touch} f1.txt f2.txt f3.txt f12.txt f21.txt f13.txt f31.txt

    \prompt\ \shcmd{touch} note.pdf image.png report.doc index.html
    \end{terminal}

    % ---

    \item Analysez les commandes suivantes :
    \begin{terminal}
    \prompt\ \shcmd{ls}

    \prompt\ \shcmd{ls} *

    \prompt\ \shcmd{echo} *

    \prompt\ \shcmd{echo} * *

    \prompt\ \shcmd{echo} * * *

    \prompt\ \shcmd{ls} *.txt

    \prompt\ \shcmd{ls} *.java

    \prompt\ \shcmd{ls} *.doc

    \prompt\ \shcmd{ls} *.*

    \prompt\ \shcmd{ls} *.TXT
    \end{terminal}

    \begin{infobox}
    Le caractère \texttt{*} correspond à n'importe quelle suite de caractères
    (dans un nom de fichier).
    \end{infobox}

    \begin{dangerbox}
    La commande \texttt{rm *} supprime tous les fichiers (non cachés) du répertoire courant.
    Elle n'affiche pas de confirmation par défaut et il n'y a pas de "corbeille".
    \texttt{rm -r *} supprimerait en plus les sous-répertoires de manière récursive.
    Vérifiez toujours votre motif avant d'utiliser \texttt{rm}.
    \end{dangerbox}

    % ---

    \item Analysez les commandes suivantes :
    \begin{terminal}
    \prompt\ \shcmd{ls} *.txt

    \prompt\ \shcmd{ls} "*.txt"

    \prompt\ \shcmd{ls} '*.txt'
    \end{terminal}
    
    \begin{infobox}
    Lorsque le motif est entouré de guillemets, le globbing n'est pas interprété par le shell.
    \begin{itemize}
        \item Les guillemets simples \texttt{' '} désactivent l'interprétation de tous les caractères spéciaux.
        \item Les guillemets doubles \texttt{" "} désactivent le globbing, mais permettent toujours
              l'expansion des variables (avec \texttt{\$VAR}) et la substitution de commande
              (avec guillemets inversés \verb|`...`| ou \texttt{\$(...)}).
    \end{itemize}
    \end{infobox}

    \item Exécutez les commandes suivantes :
    \begin{terminal}
    \prompt\ \shcmd{ls} *

    \prompt\ \shcmd{ls} .*
    \end{terminal}

    \begin{infobox}
    Par défaut, le globbing ne correspond pas aux fichiers cachés
    (commençant par un point).
    \end{infobox}

    % ---

    \item Analysez les commandes suivantes :
    \begin{terminal}
    \prompt\ \shcmd{ls} ?.txt

    \prompt\ \shcmd{ls} a?.txt

    \prompt\ \shcmd{ls} A?.txt

    \prompt\ \shcmd{ls} ?c.txt

    \prompt\ \shcmd{ls} ??.txt

    \prompt\ \shcmd{ls} ???.txt
    \end{terminal}
    
    \begin{infobox}
    Le caractère \texttt{?} correspond à exactement un caractère (ni plus, ni moins).
    \end{infobox}

    % ---

    \item Analysez les commandes suivantes :
    \begin{terminal}
    \prompt\ \shcmd{ls} [ab].txt

    \prompt\ \shcmd{ls} [ba].txt

    \prompt\ \shcmd{ls} [bc].txt

    \prompt\ \shcmd{ls} [a-z].txt

    \prompt\ \shcmd{ls} [b-e].txt

    \prompt\ \shcmd{ls} a[a-z].txt

    \prompt\ \shcmd{ls} [a-z]a.txt

    \prompt\ \shcmd{ls} f[0-9].txt

    \prompt\ \shcmd{ls} [a-z][0-9].txt

    \prompt\ \shcmd{ls} [a-z][!0-9].txt

    \prompt\ \shcmd{ls} [a-z][a-z].txt

    \prompt\ \shcmd{ls} *.[!t][!x][!t]
    \end{terminal}
    
    \begin{infobox}
    Les crochets \texttt{[ ]} permettent de rechercher un caractère parmi plusieurs possibilités.
    Par exemple, \texttt{[ab]} correspond soit à \texttt{a} soit à \texttt{b}.
    On peut aussi utiliser des intervalles, comme \texttt{[0-9]} ou \texttt{[a-z]}, et la négation,
    par exemple \texttt{[!0-9]} (tout caractère qui n'est pas un chiffre) ou \texttt{[\^{}0-9]}.
    \end{infobox}
\end{itemize}

% ---

\section{Mise en pratique : navigation dans un dépôt d'entreprise}

Dans cet exercice, vous allez télécharger un petit jeu de données qui simule
les fichiers d'une entreprise (rapports, factures, logs, sauvegardes, etc.),
puis utiliser le globbing pour retrouver certaines informations.



\begin{itemize}
    \item Téléchargez l'archive suivante dans votre répertoire \texttt{TD2} :
    \begin{terminal}
    \prompt\ \shcmd{cd} \$HOME/TD2

    \prompt\ \shcmd{wget} https://\textit{votre\_url}/entreprise\_data.tar.gz
    \end{terminal}

    Si la commande \texttt{wget} n'est pas disponible, installez-la avec :
    \begin{terminal}
    \prompt\ \tcomment{pour Linux :}

    \prompt\ \shcmd{sudo apt} update

    \prompt\ \shcmd{sudo apt} install wget
    
    
    \prompt\ \tcomment{pour macOS :}
    
    \prompt\ \shcmd{brew} install wget
    \end{terminal}

    % ---

    \item Décompressez l'archive et placez-vous dans le répertoire \texttt{entreprise\_data} :
    \begin{terminal}
    \prompt\ \shcmd{tar} xf entreprise\_data.tar.gz
  
    \prompt\ \shcmd{cd} entreprise\_data
  
    \prompt\ \shcmd{ls}
    \end{terminal}
  
    \item Le répertoire contient plusieurs sous-répertoires (par exemple \texttt{finances},
          \texttt{rh}, \texttt{ventes}, \texttt{it/logs}, \texttt{backups}), chacun avec de
          nombreux fichiers aux noms structurés.
\end{itemize}

\begin{infobox}
Dans toutes les questions suivantes, utilisez uniquement le globbing 
(\texttt{*}, \texttt{?}, \texttt{[...]}).

Vous pouvez bien sûr combiner le globbing avec des commandes comme \texttt{ls}, 
\texttt{echo}, voire \texttt{ls | wc -l} pour compter des fichiers.
\end{infobox}

\begin{enumerate}
    \item Lister tous les fichiers PDF du service \texttt{finances}.
          (Rapports trimestriels et factures.)
    \item Lister uniquement les rapports trimestriels de 2023 dans \texttt{finances}
          (les fichiers dont le nom contient \texttt{rapport-finances} et commence par \texttt{2023-}).
    \item Parmi ces rapports de 2023, lister uniquement les versions \texttt{v1} 
          (les fichiers dont le nom se termine par \texttt{-v1.pdf}).
    \item Lister toutes les factures 2023 pour le client \texttt{CLIENTA}
          dans le répertoire \texttt{finances}.
    \item Lister tous les fichiers de salaires (fichiers contenant \texttt{salaires} dans leur nom)
          dans le répertoire \texttt{rh}.
    \item Toujours dans \texttt{rh}, lister uniquement les fichiers de salaires
          marqués comme \texttt{confidentiel} (nom contenant \texttt{salaires-confidentiel}).
    \item Lister tous les fichiers CSV de chiffres d'affaires (se terminant par \texttt{.csv})
          dans le répertoire \texttt{ventes}, tous mois et toutes régions confondus.
    \item Lister uniquement les fichiers de \texttt{ventes} correspondant au mois de mars 2023
          (nom contenant \texttt{2023-03-}).
    \item Dans \texttt{it/logs}, lister tous les logs de production non compressés
          (fichiers \texttt{app-prod-...} se terminant par \texttt{.log}, mais pas \texttt{.log.gz}).
    \item Dans \texttt{it/logs}, lister les logs de production du 15 au 19 janvier 2023
          (jours \texttt{15}, \texttt{16}, \texttt{17}, \texttt{18}, \texttt{19} dans le nom de fichier).
    \item Dans \texttt{backups}, lister toutes les sauvegardes complètes (\texttt{full})
          de la base de données pour mars 2023 (fichiers contenant \texttt{backup-db-2023-03-}
          et \texttt{-full.tar.gz}).
    \item Lister tous les fichiers cachés à la racine du dépôt \texttt{entreprise\_data}
          (fichiers dont le nom commence par un point).
    \item Lister tous les fichiers qui ne sont \emph{pas} des fichiers texte PDF
          (c'est-à-dire tous les fichiers dont l'extension n'est pas \texttt{.pdf}).
          Vous pouvez ici utiliser un motif avec négation dans les crochets,
          par exemple \texttt{.[!p][!d][!f]} ou similaire.
\end{enumerate}

% --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---

\section{Premier script Bash}

L'objectif de cette question est de découvrir la création et l'exécution d'un script Bash simple.

%\rsubsection{Hello World}

\begin{itemize}
    \item Créez un répertoire nommé \texttt{TD2} dans votre répertoire personnel (\texttt{\$HOME}).
    \begin{terminal}
    \prompt\ \tcomment{d'abord, placez-vous dans votre répertoire personnel}

    \prompt\ \shcmd{cd} \$HOME

    \prompt\

    \prompt\ \tcomment{ensuite, on crée le répertoire TD2}

    \prompt\ \shcmd{mkdir} TD2

    \prompt\

    \prompt\ \tcomment{optionnel :}

    \prompt\ \shcmd{pwd}

    \prompt\ \shcmd{ls}
    \end{terminal}

    \item Placez-vous dans le répertoire \texttt{TD2} et créez un sous-répertoire nommé \texttt{Q1}.
    \begin{terminal}
    \prompt\ \tcomment{pour aller dans TD2}

    \prompt\ \shcmd{cd} TD2

    \prompt\ \tcomment{ou bien :}

    \prompt\ \shcmd{cd} \$HOME/TD2

    \prompt\

    \prompt\ \shcmd{mkdir} Q1

    \prompt\

    \prompt\ \tcomment{optionnel :}

    \prompt\ \shcmd{pwd}

    \prompt\ \shcmd{ls}
    \end{terminal}

    \item Placez-vous dans le répertoire \texttt{Q1} et créez un fichier nommé \texttt{hello.sh}.
    \begin{terminal}
    \prompt\ \tcomment{pour aller dans Q1}

    \prompt\ \shcmd{cd} Q1

    \prompt\ \tcomment{ou bien :}

    \prompt\ \shcmd{cd} \$HOME/TD2/Q1

    \prompt\

    \prompt\ \tcomment{pour créer le fichier :}

    \prompt\ \shcmd{touch} hello.sh

    \prompt\

    \prompt\ \tcomment{optionnel :}

    \prompt\ \shcmd{pwd}

    \prompt\ \shcmd{ls}
    \end{terminal}

    \begin{infobox}
    Ajouter une extension aux fichiers, comme \texttt{.sh} dans \texttt{hello.sh}, est optionnel sous Linux.
    Cependant, c'est une bonne pratique : cela facilite la lecture et permet aux éditeurs de texte
    de colorer la syntaxe.
    \end{infobox}

    \item Éditez le fichier \texttt{hello.sh} afin qu'il affiche \texttt{Hello World} à l'écran,
    en y ajoutant les lignes suivantes :
\begin{minted}{bash}
echo "Hello World";
echo "Ceci est mon premier script, mais certainement pas le dernier ;)";
\end{minted}

    \begin{infobox}
    Le point-virgule \texttt{;} est optionnel ici car chaque commande est sur une ligne distincte,
    mais il permet de séparer plusieurs commandes sur une même ligne.
    \end{infobox}

    \textit{Rappel :}  
    On peut lancer un éditeur de texte (\texttt{gedit}, \texttt{nano}, etc.) avec :
    \begin{terminal}
    \prompt\ \tcomment{pour utiliser gedit :}

    \prompt\ \shcmd{gedit} hello.sh \&

    \prompt\ \tcomment{pour utiliser nano :}

    \prompt\ \shcmd{nano} hello.sh \&
    \end{terminal}

    \begin{infobox}
    L'utilisation de \texttt{\&} permet de lancer le programme en arrière-plan
    et de conserver le contrôle du terminal.
    Le shell crée alors un processus fils pour exécuter la commande.
    \end{infobox}

    \item Exécutez le script en utilisant la commande \texttt{bash}.
    \begin{terminal}
    \prompt\ \shcmd{bash} hello.sh
    \end{terminal}

    \item Modifiez le fichier \texttt{hello.sh} pour ajouter une ligne de \textit{shebang}
    en début de fichier :
\begin{minted}{bash}
#!/usr/bin/env bash

echo "Hello World"
echo "Ceci est mon premier script, mais certainement pas le dernier ;)"
\end{minted}

    \begin{infobox}
    Le shebang \texttt{\#!/usr/bin/env bash} indique au système quel interpréteur doit être utilisé
    pour exécuter le script.
    
    Sans cette ligne, lorsque l'on tente d'exécuter le fichier avec \texttt{./hello.sh},
    le système essaie de l'exécuter comme un programme binaire, ce qui échoue car il s'agit
    d'un script texte.
    
    Il est également possible d'utiliser \texttt{\#!/bin/bash}. Cependant, avec
    \texttt{\#!/usr/bin/env bash}, le système utilise la commande \texttt{env} pour rechercher
    automatiquement l'interpréteur \texttt{bash} dans les chemins définis par la variable
    \texttt{PATH}, ce qui rend le script plus portable d'un système à un autre.
    \end{infobox}

    \item Si on inspecte les droits du fichier avec :
    \begin{terminal}
    \prompt\ \shcmd{ls} -l hello.sh
    \end{terminal}
    on constate qu'il n'est pas exécutable par défaut (\texttt{-rw-rw-r--}).
    Pour le rendre exécutable (\texttt{-rwxrwxr-x}), on utilise :
    \begin{terminal}
    \prompt\ \shcmd{chmod} +x hello.sh
    \end{terminal}

    \begin{infobox}
    Les droits d'un fichier sont définis par :
    \begin{itemize}
        \item \texttt{r} : droit de lecture (read)
        \item \texttt{w} : droit d'écriture (write)
        \item \texttt{x} : droit d'exécution (execute)
    \end{itemize}
    Ces droits sont définis pour le propriétaire du fichier, le groupe et les autres utilisateurs.
    \end{infobox}

    \item Exécutez le script directement, sans utiliser la commande \texttt{bash}.
    \begin{terminal}
    \prompt\ \tcomment{avec un chemin relatif :}

    \prompt\ ./hello.sh

    \prompt\ \tcomment{avec un chemin absolu :}

    \prompt\ \$HOME/TD2/Q1/hello.sh
    \end{terminal}

    \item Essayez de l'exécuter sans préciser de chemin :
    \begin{terminal}
    \prompt\ hello.sh
    \end{terminal}

    \begin{infobox}
    Cette commande ne fonctionne pas car le répertoire courant n'est pas inclus
    dans la variable d'environnement \texttt{PATH}.
    Contrairement à des commandes comme \texttt{ls} ou \texttt{pwd},
    le shell ne sait pas où chercher \texttt{hello.sh}.
    \end{infobox}

    \item Modifiez le script pour définir une variable nommée \texttt{prenom}
    contenant votre prénom, et affichez le message :
\begin{minted}{bash}
#!/usr/bin/env bash

prenom="Toto"

echo "Coucou ${prenom}"
\end{minted}

    \begin{infobox}
    Il est recommandé d'utiliser \texttt{\{\}} autour des variables afin d'éviter
    toute ambiguïté lors de l'expansion.
    \end{infobox}
    
    \item Modifiez le script afin de lire le prénom lors de l'exécution à l'aide de la commande \texttt{read}.
\begin{minted}{bash}
#!/usr/bin/env bash

echo "Entrez votre prénom :"
read prenom

echo "Coucou ${prenom}"
\end{minted}

    \item Modifiez le script afin que le prénom soit fourni comme argument
    lors de l'exécution du script.
\begin{minted}{bash}
#!/usr/bin/env bash

prenom=$1

echo "Coucou ${prenom}"
\end{minted}

    \begin{infobox}
    Lors de l'exécution d'un script Bash, certaines variables spéciales sont définies automatiquement.

    \texttt{\$0} contient le nom du script tel qu'il a été utilisé pour le lancer.

    \texttt{\$1}, \texttt{\$2}, \ldots \, correspondent aux arguments passés au script :
    \texttt{\$1} est le premier argument, \texttt{\$2} le second, etc.
    \end{infobox}

    \item Modifiez le script afin de demander également l'âge de l'utilisateur,
    puis affichez un message prenant en compte cet âge.

\begin{minted}{bash}
#!/usr/bin/env bash

prenom=$1
age=$2

echo "Coucou ${prenom}"
echo "J'espère que ton ${age}e anniversaire s'est bien passé !"
\end{minted}

    \item Modifiez le script afin d'afficher une phrase indiquant que le prochain anniversaire
    sera encore meilleur, en utilisant un calcul sur l'âge.
\begin{minted}{bash}
#!/usr/bin/env bash

prenom=$1
age=$2

echo "Coucou ${prenom}"
echo "J'espère que ton ${age}e anniversaire s'est bien passé !"

prochain_age=$((age + 1))
echo "Le ${prochain_age}e sera encore meilleur :)"
\end{minted}

    \item Modifiez le script afin de réaliser l'affichage à l'aide d'un stégosaure
    (en utilisant \texttt{cowsay}).
\begin{minted}{bash}
#!/usr/bin/env bash

prenom=$1
age=$2

cowsay -f stegosaurus "Coucou ${prenom}"
cowsay -f stegosaurus "J'espère que ton ${age}e anniversaire s'est bien passé !"

prochain_age=$((age + 1))
cowsay -f stegosaurus "Le ${prochain_age}e sera encore meilleur :)"
\end{minted}
\end{itemize}


% --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---

\section{Récupération des fichiers de données}
Dans ce TD, vous allez travailler sur des fichiers texte fournis par l'enseignant.
Ces fichiers contiennent des données fictives destinées à l'apprentissage
des commandes de filtrage et d'analyse de texte.

Commencez par créer un répertoire \texttt{data}, puis téléchargez les fichiers
à l'aide des commandes suivantes :

\begin{terminal}
\prompt\ \shcmd{mkdir} data

\prompt\ \shcmd{cd} data

\prompt\ \shcmd{wget} https://raw.githubusercontent.com/AbdAmmar/LDS/main/TD/TD2/data/users.txt

\prompt\ \shcmd{wget} https://raw.githubusercontent.com/AbdAmmar/LDS/main/TD/TD2/data/logs.txt

\prompt\ \shcmd{wget} https://raw.githubusercontent.com/AbdAmmar/LDS/main/TD/TD2/data/notes.txt
\end{terminal}

Vérifiez que les fichiers ont bien été téléchargés.
Si la commande \texttt{wget} n'est pas disponible, installez-la avec :

\begin{terminal}
\prompt\ \shcmd{sudo} apt update

\prompt\ \shcmd{sudo} apt install wget
\end{terminal}

% --------------------------------------------------
\section{Lire et compter}

\subsection*{Travail à faire}

\begin{enumerate}
    \item Affichez le contenu du fichier \texttt{users.txt}.
    \item Comptez le nombre de lignes du fichier.
    \item Affichez le contenu du fichier \texttt{logs.txt}.
    \item Comptez le nombre de lignes du fichier \texttt{notes.txt}.
\end{enumerate}

\subsection*{Commandes utiles}

\begin{terminal}
\prompt\ \shcmd{cat} users.txt

\prompt\ \shcmd{wc} \texttt{-l} users.txt
\end{terminal}

% --------------------------------------------------
\section{Introduction aux pipes}

Un \textit{pipe} permet d'envoyer la sortie d'une commande en entrée d'une autre.

\subsection*{Travail à faire}

\begin{enumerate}
    \item Comptez le nombre de lignes de \texttt{users.txt} sans afficher le contenu du fichier.
    \item Expliquez le rôle du symbole \texttt{|}.
\end{enumerate}

\subsection*{Commande clé}

\begin{terminal}
\prompt\ \shcmd{cat} users.txt \texttt{|} \shcmd{wc} \texttt{-l}
\end{terminal}

% --------------------------------------------------
\section{Rechercher des informations avec \texttt{grep}}

\subsection*{Travail à faire}

À partir du fichier \texttt{users.txt} :

\begin{enumerate}
    \item Affichez les lignes contenant \texttt{bash}.
    \item Comptez le nombre d'utilisateurs utilisant \texttt{bash}.
    \item Affichez les lignes ne contenant pas \texttt{bash}.
\end{enumerate}

\subsection*{Commandes utiles}

\begin{terminal}
\prompt\ \shcmd{grep} bash users.txt

\prompt\ \shcmd{grep} \texttt{-c} bash users.txt

\prompt\ \shcmd{grep} \texttt{-v} bash users.txt
\end{terminal}

% --------------------------------------------------
\section{Extraire des informations}

Le fichier \texttt{users.txt} est structuré : les champs sont séparés par le caractère \texttt{:}.

\subsection*{Travail à faire}

\begin{enumerate}
    \item Affichez uniquement la colonne des noms d'utilisateurs.
    \item Affichez uniquement la colonne des shells.
\end{enumerate}

\subsection*{Commandes utiles}

\begin{terminal}
\prompt\ \shcmd{cut} \texttt{-d: -f1} users.txt

\prompt\ \shcmd{cut} \texttt{-d: -f2} users.txt
\end{terminal}

% --------------------------------------------------
\section{Trier et compter}

\subsection*{Travail à faire}

\begin{enumerate}
    \item Affichez la liste des shells utilisés.
    \item Triez cette liste.
    \item Comptez combien de fois chaque shell apparaît.
\end{enumerate}

\subsection*{Pipeline attendu}

\begin{terminal}
\prompt\ \shcmd{cut} \texttt{-d: -f2} users.txt \texttt{|} \shcmd{sort} \texttt{|} \shcmd{uniq} \texttt{-c}
\end{terminal}

% --------------------------------------------------
\section{Analyse de fichiers de logs}

\subsection*{Travail à faire}

À partir du fichier \texttt{logs.txt} :

\begin{enumerate}
    \item Affichez uniquement les lignes contenant \texttt{ERROR}.
    \item Comptez le nombre d'erreurs.
    \item Affichez les noms des utilisateurs ayant généré une erreur.
\end{enumerate}

\subsection*{Commandes utiles}

\begin{terminal}
\prompt\ \shcmd{grep} ERROR logs.txt

\prompt\ \shcmd{grep} \texttt{-c} ERROR logs.txt

\prompt\ \shcmd{grep} ERROR logs.txt \texttt{|} \shcmd{cut} \texttt{-d= -f2}
\end{terminal}

% --------------------------------------------------
\section{Mini-analyse}

\subsection*{Travail à faire}

Sans utiliser d'éditeur de texte :

\begin{itemize}
    \item Quel est le shell le plus utilisé ?
    \item Quel utilisateur apparaît le plus souvent dans les logs ?
\end{itemize}

Justifiez vos réponses à l'aide de commandes Linux.




% --------------------------------------------------
\section{Les flux standards}

Ce TD a pour objectif d'introduire la gestion des sorties et des erreurs
sous Linux.
Sous Linux, un programme communique avec l'extérieur à l'aide de flux :
\begin{itemize}
    \item l'entrée standard (stdin) ;
    \item la sortie standard (stdout) ;
    \item la sortie d'erreur (stderr).
\end{itemize}

Par défaut, la sortie standard et la sortie d'erreur sont affichées à l'écran.

% --------------------------------------------------
\section{Rediriger la sortie standard}

\subsection*{Travail à faire}

\begin{enumerate}
    \item Listez le contenu de votre répertoire personnel.
    \item Redirigez cette sortie dans un fichier \texttt{liste.txt}.
    \item Vérifiez le contenu du fichier.
\end{enumerate}

\subsection*{Commandes}

\begin{terminal}
\prompt\ \shcmd{ls}

\prompt\ \shcmd{ls} \texttt{>} liste.txt

\prompt\ \shcmd{cat} liste.txt
\end{terminal}

% --------------------------------------------------
\section{Générer et observer une erreur}

\subsection*{Travail à faire}

\begin{enumerate}
    \item Essayez d'afficher un fichier qui n'existe pas.
    \item Observez le message affiché.
\end{enumerate}

\begin{terminal}
\prompt\ \shcmd{cat} fichier\_inexistant.txt
\end{terminal}

Expliquez pourquoi le message n'est pas redirigé avec \texttt{>}.

% --------------------------------------------------
\section{Rediriger la sortie d'erreur}

La sortie d'erreur peut être redirigée séparément.

\subsection*{Travail à faire}

\begin{enumerate}
    \item Redirigez l'erreur précédente dans un fichier \texttt{erreur.txt}.
    \item Vérifiez le contenu du fichier.
\end{enumerate}

\begin{terminal}
\prompt\ \shcmd{cat} fichier\_inexistant.txt \texttt{2>} erreur.txt

\prompt\ \shcmd{cat} erreur.txt
\end{terminal}

% --------------------------------------------------
\section{Rediriger sortie et erreur}

Il est possible de rediriger à la fois la sortie standard et la sortie d'erreur.

\subsection*{Travail à faire}

\begin{enumerate}
    \item Lancez une commande produisant à la fois une sortie et une erreur.
    \item Redirigez les deux flux dans un même fichier.
\end{enumerate}

\begin{terminal}
\prompt\ \shcmd{ls} fichier\_inexistant \texttt{>} sortie.txt \texttt{2>} erreur.txt
\end{terminal}

Ou en une seule commande :

\begin{terminal}
\prompt\ \shcmd{ls} fichier\_inexistant \texttt{>} tout.txt \texttt{2>\&1}
\end{terminal}

\end{document}
