\documentclass[11pt,a4paper]{article}

\usepackage[T1]{fontenc}
\usepackage[french]{babel}
\usepackage{geometry}

\usepackage{../../ldsstyle}

\geometry{margin=2.5cm}

\title{TD2 -- Langages de script}
\author{Abdallah Ammar}
\date{\today}

\begin{document}
\maketitle



\begin{warningbox}
Il est fortement recommandé de taper les commandes à la main afin de se familiariser
avec le terminal.
\end{warningbox}


\begin{warningbox}
Ce TP introduit de nombreuses notions nouvelles.
Il est fortement recommandé de prendre des notes au fur et à mesure.
\end{warningbox}

\begin{warningbox}
Avant de regarder les solutions proposées dans ce TD, prenez le temps de réfléchir
et de tenter de résoudre les questions par vous-même.
L'erreur fait partie du processus d'apprentissage.
\end{warningbox}



\bigskip









% --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---

\section{Séquences simples}

\begin{itemize}
    \item Analysez les résultats des commandes suivantes :
    \begin{terminal}
    \prompt\ \shcmd{echo} \{1..5\}

    \prompt\ \shcmd{echo} \{5..1\}

    \prompt\ \shcmd{echo} \{15..-10\}

    \prompt\ \shcmd{echo} \{a..z\}

    \prompt\ \shcmd{echo} \{h..c\}
    \end{terminal}

    \begin{infobox}
    La syntaxe \texttt{\{début..fin\}} permet de générer une séquence de 
    nombres ou de caractères, selon l'ordre croissant ou décroissant.
    \end{infobox}

    % ---

    \item Créez un répertoire nommé \texttt{TD2} dans votre répertoire personnel (\texttt{\$HOME}).
    \begin{terminal}
    \prompt\ \tcomment{d'abord, placez-vous dans votre répertoire personnel}

    \prompt\ \shcmd{cd} \$HOME

    \prompt\

    \prompt\ \tcomment{ensuite, on crée le répertoire TD2}

    \prompt\ \shcmd{mkdir} TD2

    \prompt\

    \prompt\ \tcomment{optionnel :}

    \prompt\ \shcmd{pwd}

    \prompt\ \shcmd{ls}
    \end{terminal}

    % ---

    \item Placez-vous dans le répertoire \texttt{TD2} et créez un sous-répertoire nommé \texttt{Q1}.
    \begin{terminal}
    \prompt\ \tcomment{pour aller dans TD2}

    \prompt\ \shcmd{cd} TD2

    \prompt\ \tcomment{ou bien :}

    \prompt\ \shcmd{cd} \$HOME/TD2

    \prompt\

    \prompt\ \shcmd{mkdir} Q1

    \prompt\

    \prompt\ \tcomment{optionnel :}

    \prompt\ \shcmd{pwd}

    \prompt\ \shcmd{ls}
    \end{terminal}

    % ---

    \item Placez-vous dans le répertoire \texttt{Q1} et créez 12 répertoires nommés 
    \texttt{moi\_1}, \texttt{moi\_2}, \ldots, \texttt{moi\_12} en 
    utilisant une seule commande.
    \begin{terminal}
    \prompt\ \shcmd{cd} Q1

    \prompt\

    \prompt\ \shcmd{mkdir} moi\_\{1..12\}

    \prompt\ \tcomment{pour vérifier}

    \prompt\ \shcmd{ls}
    \end{terminal}

    % ---

    \item Sans changer de répertoire, créez 30 fichiers nommés \texttt{jour\_1.txt}, \texttt{jour\_2.txt}, 
    \ldots, \texttt{jour\_30.txt} dans chacun des répertoires \texttt{moi\_1} à \texttt{moi\_12},
    toujours avec une seule commande.
    \begin{terminal}
    \prompt\ \shcmd{touch} moi\_\{1..12\}/jour\_\{1..30\}.txt

    \prompt\ \tcomment{pour vérifier}

    \prompt\ \shcmd{ls *}
    \end{terminal}
\end{itemize}



% --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---





\section{Globbing}

Le \textit{globbing} est un mécanisme du shell permettant de faire correspondre
des motifs (\textit{patterns}) à des noms de fichiers.

\begin{infobox}
Le globbing est effectué par le shell avant l'exécution de la commande.
Les caractères \texttt{*}, \texttt{?} et \texttt{[...]} ont une signification
particulière et peuvent être désactivés à l'aide de guillemets ou d'un antislash (\texttt{\textbackslash}).
\end{infobox}

\begin{itemize}
    \item Placez-vous dans le répertoire \texttt{TD2} et créez un sous-répertoire nommé \texttt{Q2}.
    \begin{terminal}
    \prompt\ \shcmd{cd} \$HOME/TD2

    \prompt\

    \prompt\ \shcmd{mkdir} Q2

    \prompt\

    \prompt\ \tcomment{optionnel :}

    \prompt\ \shcmd{pwd}

    \prompt\ \shcmd{ls}
    \end{terminal}

    % ---

    \item Placez-vous dans le répertoire \texttt{Q2} et créez les fichiers suivants :
    \begin{terminal}
    \prompt\ \tcomment{pour aller dans Q2}

    \prompt\ \shcmd{cd} Q2

    \prompt\

    \prompt\ \shcmd{touch} a.txt b.txt c.txt aa.txt bb.txt cc.txt

    \prompt\ \shcmd{touch} a.java b.java c.java

    \prompt\ \shcmd{touch} ba.txt ab.txt ca.txt ac.txt

    \prompt\ \shcmd{touch} f1.txt f2.txt f3.txt f12.txt f21.txt f13.txt f31.txt

    \prompt\ \shcmd{touch} note.pdf image.png report.doc index.html
    \end{terminal}

    % ---

    \item Analysez les résultats des commandes suivantes :
    \begin{terminal}
    \prompt\ \shcmd{ls}

    \prompt\ \shcmd{ls} *

    \prompt\ \shcmd{echo} *

    \prompt\ \shcmd{echo} * *

    \prompt\ \shcmd{echo} * * *

    \prompt\ \shcmd{ls} *.txt

    \prompt\ \shcmd{ls} *.java

    \prompt\ \shcmd{ls} *.doc

    \prompt\ \shcmd{ls} *.*

    \prompt\ \shcmd{ls} *.TXT
    \end{terminal}

    \begin{infobox}
    Le caractère \texttt{*} correspond à n'importe quelle suite de caractères
    (dans un nom de fichier).
    \end{infobox}

    \begin{dangerbox}
    La commande \texttt{rm *} supprime tous les fichiers (non cachés) du répertoire courant.
    Elle n'affiche pas de confirmation par défaut et il n'y a pas de "corbeille".
    \texttt{rm -r *} supprimerait en plus les sous-répertoires de manière récursive.
    Vérifiez toujours votre motif avant d'utiliser \texttt{rm}.
    \end{dangerbox}

    % ---

    \item Analysez les résultats des commandes suivantes :
    \begin{terminal}
    \prompt\ \shcmd{ls} *.txt

    \prompt\ \shcmd{ls} "*.txt"

    \prompt\ \shcmd{ls} '*.txt'
    \end{terminal}
    
    \begin{infobox}
    Lorsque le motif est entouré de guillemets, le globbing n'est pas interprété par le shell.
    \begin{itemize}
        \item Les guillemets simples \texttt{' '} désactivent l'interprétation de tous les caractères spéciaux.
        \item Les guillemets doubles \texttt{" "} désactivent le globbing, mais permettent toujours
              l'expansion des variables (avec \texttt{\$}) et la substitution de commande
              (avec guillemets inversés \verb|`...`| ou \texttt{\$(...)}).
    \end{itemize}
    \end{infobox}

    % ---

    \item Exécutez les commandes suivantes :
    \begin{terminal}
    \prompt\ \shcmd{ls} *

    \prompt\ \shcmd{ls} .*
    \end{terminal}

    \begin{infobox}
    Par défaut, le globbing ne correspond pas aux fichiers cachés
    (commençant par un point).
    \end{infobox}

    % ---

    \item Analysez les résultats des commandes suivantes :
    \begin{terminal}
    \prompt\ \shcmd{ls} ?.txt

    \prompt\ \shcmd{ls} a?.txt

    \prompt\ \shcmd{ls} A?.txt

    \prompt\ \shcmd{ls} ?c.txt

    \prompt\ \shcmd{ls} ??.txt

    \prompt\ \shcmd{ls} ???.txt
    \end{terminal}
    
    \begin{infobox}
    Le caractère \texttt{?} correspond à exactement un caractère (ni plus, ni moins).
    \end{infobox}

    % ---

    \item Analysez les résultats des commandes suivantes :
    \begin{terminal}
    \prompt\ \shcmd{ls} [ab].txt

    \prompt\ \shcmd{ls} [ba].txt

    \prompt\ \shcmd{ls} [bc].txt

    \prompt\ \shcmd{ls} [a-z].txt

    \prompt\ \shcmd{ls} [b-e].txt

    \prompt\ \shcmd{ls} a[a-z].txt

    \prompt\ \shcmd{ls} [a-z]a.txt

    \prompt\ \shcmd{ls} f[0-9].txt

    \prompt\ \shcmd{ls} [a-z][0-9].txt

    \prompt\ \shcmd{ls} [a-z][!0-9].txt

    \prompt\ \shcmd{ls} [a-z][a-z].txt

    \prompt\ \shcmd{ls} *.[!t][!x][!t]
    \end{terminal}
    
    \begin{infobox}
    Les crochets \texttt{[ ]} permettent de rechercher un caractère parmi plusieurs possibilités.
    Par exemple, \texttt{[ab]} correspond soit à \texttt{a} soit à \texttt{b}.
    On peut aussi utiliser des intervalles, comme \texttt{[0-9]} ou \texttt{[a-z]}, et la négation,
    par exemple \texttt{[!0-9]} (tout caractère qui n'est pas un chiffre) ou \texttt{[\^{}0-9]}.
    \end{infobox}
\end{itemize}





% --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---





\section{Expressions régulières (regex) avec \texttt{grep}}

Dans cette exercice, nous allons utiliser des expressions régulières (\emph{regex})
avec la commande \texttt{grep} pour rechercher des motifs dans des fichiers texte.

\begin{infobox}
Globbing vs Regex
\begin{itemize}
    \item Le globbing sert à faire correspondre des motifs à des noms de fichiers.
    \item Les expressions régulières décrivent des motifs à l'intérieur du
          contenu des fichiers (les lignes de texte).
\end{itemize}
\end{infobox}

\begin{itemize}
    \item Créez un sous-répertoire \texttt{Q3} dans \texttt{TD2} et placez-vous dedans.
    \begin{terminal}
    \prompt\ \shcmd{cd} \$HOME/TD2
  
    \prompt\ \shcmd{mkdir} Q3
  
    \prompt\ \shcmd{cd} Q3
    \end{terminal}

    % ---

    \item
    Téléchargez le fichier \texttt{donnees.txt} pour amalyser des commandes \texttt{grep}.
    \begin{terminal}
    \prompt \tcomment{Je définis l'URL du dépôt GitHub}

    \prompt\ UrlGit="https://raw.githubusercontent.com/AbdAmmar/LDS/main"

    \prompt \tcomment{Chemin du fichier à télécharger}

    \prompt\ Rep="TD/TD2/data/regex/donnees.txt"

    \prompt\

    \prompt \tcomment{Téléchargement du fichier}
    
    \prompt\ \shcmd{curl} -LO "\$\{UrlGit\}/\$\{Rep\}"

    \prompt\

    \prompt \tcomment{Vérifiez que le fichier a bien été téléchargé}

    \prompt\ \shcmd{ls} donnees.txt
    \end{terminal}
\end{itemize}

% ---

\subsection{Commande \texttt{grep}} 

\begin{itemize}
    \item Affichez toutes les lignes contenant le mot \texttt{user}.
    \begin{terminal}
    \prompt\ \shcmd{grep} 'user' donnees.txt
    \end{terminal}

    % ---

    \item Affichez toutes les lignes contenant des codes postaux avec le numéro des lignes.
    \begin{terminal}
    \prompt\ \shcmd{grep} -n 'code postal' donnees.txt
    \end{terminal}

    % ---

    \item Affichez toutes les lignes contenant une adresse e-mail quelconque (celles qui contiennent le caractère \texttt{@}).
    \begin{terminal}
    \prompt\ \shcmd{grep} '@' donnees.txt
    \end{terminal}
  
    % ---

    \item Analysez les résultats des commandes suivantes :
    \begin{terminal}
    \prompt\ \shcmd{grep} 'info' donnees.txt

    \prompt\ \shcmd{grep} -i 'info' donnees.txt

    \prompt\ \shcmd{grep} -in 'info' donnees.txt
    \end{terminal}

    \begin{infobox}
    Par défaut, \texttt{grep} distingue les majuscules et les minuscules.
    Avec l'option \texttt{-i} (\emph{ignore case}), la recherche devient
    insensible à la casse.
    \end{infobox}

    % ---

    \item Analysez les résultats des commandes suivantes :
    \begin{terminal}
    \prompt\ \shcmd{grep} '1' donnees.txt

    \prompt\ \shcmd{grep} -v '1' donnees.txt

    \prompt\ \shcmd{grep} '11' donnees.txt

    \prompt\ \shcmd{grep} -v '11' donnees.txt
    \end{terminal}

    \begin{infobox}
    \texttt{grep -v motif} affiche les lignes qui ne correspondent pas au motif.
    C'est l'inverse de \texttt{grep motif}.
    \end{infobox}
\end{itemize}

% ---

\subsection{Ancrages \texttt{\^{}} (début de ligne) et \texttt{\$} (fin de ligne)}

\begin{itemize}
    \item Analysez les résultats des commandes suivantes :
    \begin{terminal}
    \prompt\ \shcmd{grep} '\$' donnees.txt

    \prompt\ \shcmd{grep} '\textbackslash \$' donnees.txt

    \prompt\ \shcmd{grep} 'H\$' donnees.txt

    \prompt\ \shcmd{grep} 'HH\$' donnees.txt

    \prompt\ \shcmd{grep} '000\$' donnees.txt
    \end{terminal}

    \begin{infobox}
    Dans une expression régulière, le symbole \texttt{\$} ne signifie pas ``caractère dollar'' :
    il signifie ``fin de ligne''.
    Pour chercher un vrai \texttt{\$} dans le texte, il faut utiliser \texttt{\textbackslash\$}.
    \end{infobox}

    % ---

    \item Analysez les résultats des commandes suivantes :
    \begin{terminal}
    \prompt\ \shcmd{grep} '\^{}' donnees.txt

    \prompt\ \shcmd{grep} '\textbackslash \^{}' donnees.txt

    \prompt\ \shcmd{grep} '\^{}e' donnees.txt

    \prompt\ \shcmd{grep} -i '\^{}e' donnees.txt

    \prompt\ \shcmd{grep} -i '\^{}er' donnees.txt
    \end{terminal}

    \begin{infobox}
    En expression régulière, le symbole \texttt{\^{}} ne signifie pas ``caractère \texttt{\^{}} littéral'' :
    il signifie ``début de ligne''.
    Pour chercher un vrai \texttt{\^{}} dans le texte, il faut utiliser \texttt{\textbackslash\^{}}.
    \end{infobox}

    % ---

    \item Analysez les résultats des commandes suivantes :
    \begin{terminal}
    \prompt\ \shcmd{grep} '[\textbackslash \$]' donnees.txt

    \prompt\ \shcmd{grep} '[\$]' donnees.txt

    \prompt\ \shcmd{grep} '[\^{}]' donnees.txt

    \prompt\ \shcmd{grep} '[\textbackslash \^{}]' donnees.txt

    \prompt\ \shcmd{grep} '\^{}M' donnees.txt

    \prompt\ \shcmd{grep} '\^{}[M]' donnees.txt

    \prompt\ \shcmd{grep} '\^{}[\^{}M]' donnees.txt

    \prompt\ \shcmd{grep} '[\^{}Z]' donnees.txt

    \prompt\ \shcmd{grep} '[Z\^{}]' donnees.txt
    \end{terminal}

    \begin{infobox}
    \texttt{\^{}} et \texttt{\$} servent d'ancres (début/fin de ligne) uniquement \emph{en dehors}
    des crochets \texttt{[ ]}. À l'intérieur, ils sont soit de la syntaxe de classe négative
    (\texttt{[\^{}...]}) soit de simples caractères normaux.
    \end{infobox}
\end{itemize}

% ---

\subsection{Regex de base (\texttt{.}, \texttt{[ ]}, \texttt{*})}

\begin{itemize}
    \item Analysez les résultats des commandes suivantes :
    \begin{terminal}
    \prompt\ \shcmd{grep} '.' donnees.txt

    \prompt\ \shcmd{grep} '\textbackslash.' donnees.txt

    \prompt\ \shcmd{grep}  'se.' donnees.txt
    
    \prompt\ \shcmd{grep} 'se\textbackslash.' donnees.txt

    \prompt\ \shcmd{grep} '2.:' donnees.txt

    \prompt\ \shcmd{grep} '.2.1.w' donnees.txt

    \prompt\ \shcmd{grep} ':..:' donnees.txt

    \prompt\ \shcmd{grep} ':...:' donnees.txt

    \prompt\ \shcmd{grep} 'com' donnees.txt

    \prompt\ \shcmd{grep} 'com.' donnees.txt
    \end{terminal}

    \begin{infobox}
    Dans une expression régulière, le caractère \texttt{.} signifie ``un caractère quelconque''.
    Pour chercher un \emph{vrai} point, on l'échappe avec un antislash \texttt{\textbackslash}.
    \end{infobox}

    % ---

    \item Analysez les résultats des commandes suivantes :
    \begin{terminal}
    \prompt\ \shcmd{grep} '*' donnees.txt

    \prompt\ \shcmd{grep} '\textbackslash*' donnees.txt

    \prompt\ \shcmd{grep} 'K*' donnees.txt

    \prompt\ \shcmd{grep} '*K' donnees.txt

    \prompt\ \shcmd{grep} '\textbackslash*K' donnees.txt

    \prompt\ \shcmd{grep} 'V*' donnees.txt

    \prompt\ \shcmd{grep} 'V\textbackslash*' donnees.txt

    \prompt\ \shcmd{grep} 'V*V' donnees.txt

    \prompt\ \shcmd{grep} 'V*VV' donnees.txt

    \prompt\ \shcmd{grep} 'tel: 01*' donnees.txt
    \end{terminal}

    \begin{infobox}
    Dans une expression régulière, le caractère \texttt{*} n'est pas un caractère
    normal : c'est un ``quantificateur'' qui signifie ``zéro ou plusieurs
    occurrences de l'élément précédent''.
    Pour chercher un \emph{vrai} caractère \texttt{*}, on l'échappe avec un antislash \texttt{\textbackslash} 
    (si \texttt{*} est precede par un autre character).
    \end{infobox}

    % ---

    \item Analysez les résultats des commandes suivantes :
    \begin{terminal}
    \prompt\ \shcmd{grep} '[' donnees.txt

    \prompt\ \shcmd{grep} '\textbackslash [' donnees.txt

    \prompt\ \shcmd{grep} '[[]' donnees.txt

    \prompt\ \shcmd{grep} '[aeiou]' donnees.txt
    
    \prompt\ \shcmd{grep} '[x-z]' donnees.txt

    \prompt\ \shcmd{grep} '[xz-]' donnees.txt
    
    \prompt\ \shcmd{grep} '[x-zX-Z]' donnees.txt
    
    \prompt\ \shcmd{grep} '[0-3]' donnees.txt
    
    \prompt\ \shcmd{grep} '[\^{}a-zA-Z0-9]' donnees.txt
    \end{terminal}

    \begin{infobox}
    Dans une expression régulière, \texttt{[...]} définit une ``classe de caractères'' :
    la regex correspond à \emph{un seul caractère} parmi ceux listés entre les crochets.
    \begin{itemize}
        \item \texttt{[aeiou]} : une lettre parmi \texttt{a}, \texttt{e}, \texttt{i}, \texttt{o}, \texttt{u}.
        \item \texttt{[0-9]} : un chiffre (de 0 à 9).
        \item \texttt{[A-Z]} : une lettre majuscule.
        \item \texttt{[A-Za-z0-9\_]} : lettre majuscule, ou minuscule, ou chiffre, ou \texttt{\_}.
    \end{itemize}
    On peut aussi utiliser une ``classe négative'' avec \texttt{\^{}} en premier caractère :
    \begin{itemize}
        \item \texttt{[\^{}0-9]} : un caractère qui n'est pas un chiffre.
    \end{itemize}
    \end{infobox}
\end{itemize}

% ---

\subsection{Quantificateurs : \texttt{+}, \texttt{?}, \texttt{\{m,n\}}}

\begin{itemize}
    \item Analysez les résultats des commandes suivantes :
    \begin{terminal}
    \prompt\ \shcmd{grep} 'a*' donnees.txt

    \prompt\ \shcmd{grep} 'a\textbackslash+' donnees.txt

    \prompt\ \shcmd{grep} 'a+' donnees.txt

    \prompt\ \shcmd{grep} -E 'a\textbackslash+' donnees.txt

    \prompt\ \shcmd{grep} -E 'a+' donnees.txt

    \prompt\ \shcmd{grep} -E 's+s+' donnees.txt
    
    \prompt\ \shcmd{grep} -E 'ss+' donnees.txt
    
    \prompt\ \shcmd{grep} -E '1+2+3+' donnees.txt
    
    \prompt\ \shcmd{grep} -E '123+' donnees.txt 

    \prompt\ \shcmd{grep} -E 'a+t' donnees.txt
    \end{terminal}

    \begin{infobox}
    Dans les regex, \texttt{+} désigne ``une ou plusieurs occurrences'' du motif précédent. \\
    Avec \texttt{grep} (regex basiques), il faut l'écrire \texttt{\textbackslash+}.  
    Avec \texttt{grep -E} (regex étendues), on écrit simplement \texttt{+}.
    \end{infobox}

    % ---

    \item Analysez les résultats des commandes suivantes :
    \begin{terminal}
    \prompt\ \shcmd{grep} '4' donnees.txt

    \prompt\ \shcmd{grep} '4\textbackslash?' donnees.txt

    \prompt\ \shcmd{grep} -E '4?' donnees.txt

    \prompt\ \shcmd{grep} -E '4\textbackslash?' donnees.txt
    \end{terminal}

    \begin{infobox}
    Dans les regex, \texttt{?} signifie ``zéro ou une occurrence'' du motif précédent. \\
    Avec \texttt{grep} (regex basiques), il faut l'écrire \texttt{\textbackslash?}.  
    Avec \texttt{grep -E} (regex étendues), on écrit simplement \texttt{?}.
    \end{infobox}

    % ---

    \item Analysez les résultats des commandes suivantes :
    \begin{terminal}
    \prompt\ \shcmd{grep} '[0-9]' donnees.txt

    \prompt\ \shcmd{grep} '[0-9][0-9][0-9][0-9][0-9]' donnees.txt

    \prompt\ \shcmd{grep} '[0-9]\{5\}' donnees.txt

    \prompt\ \shcmd{grep} '[0-9]\textbackslash\{5\textbackslash\}' donnees.txt

    \prompt\ \shcmd{grep} -E '[0-9]\{5\}' donnees.txt

    \prompt\ \shcmd{grep} -E '[0-9]\textbackslash\{5\textbackslash\}' donnees.txt

    \prompt\ \shcmd{grep} -E '[0-9]\{3,6\}' donnees.txt

    \prompt\ \shcmd{grep} -E '[0-9]\{4\}-[0-9]\{2\}-[0-9]\{2\}' donnees.txt

    \prompt\ \shcmd{grep} -E '[0-9]\{4\}-[0-9]\{2\}-[0-9]\{2\}\$' donnees.txt

    \prompt\ \shcmd{grep} -E '[A-Z]\{6,8\}: \textbackslash\$[0-9]\{4\}' donnees.txt

    \prompt\ \shcmd{grep} -E '[0-9]\{2\}/[0-9]\{2\}/[0-9]\{4\}' donnees.txt

    \prompt\ \shcmd{grep} -Ev '[0-9]' donnees.txt
    \end{terminal}

    \begin{infobox}
    Avec \texttt{grep} \emph{(sans \texttt{-E})}, on utilise les ``regex basiques''.
    La répétition se fait avec \texttt{\textbackslash\{m\textbackslash\}} ou 
    \texttt{\textbackslash\{m,n\textbackslash\}}.

    Avec \texttt{grep -E},  on active les ``regex étendues''. Ici, \texttt{\{ \}}
    sont directement des quantificateurs, \emph{sans antislash}.
    \begin{itemize}
        \item \texttt{\{m\}} = exactement \texttt{m} répétitions.
        \item \texttt{\{m,n\}} = entre \texttt{m} et \texttt{n} répétitions.
    \end{itemize}
    \end{infobox}

    % ---

    \item Affichez toutes les lignes qui ne contiennent pas des lettres majuscules.
    \begin{terminal}
    \prompt\ \shcmd{grep} -Ev '[A-Z]' donnees.txt
    \end{terminal}

    % ---

    \item Affichez toutes les lignes qui ne contiennent pas des lettres (majuscules ou minusclues) entre
    \texttt{A} et \texttt{D}.
    \begin{terminal}
    \prompt\ \shcmd{grep} -Ev '[A-Da-d]' donnees.txt
    \end{terminal}
\end{itemize}

% ---

\subsection{Alternatives \texttt{|} et groupes \texttt{( )}}

\begin{itemize}
    \item Analysez les résultats des commandes suivantes :
    \begin{terminal}
    \prompt\ \shcmd{grep} 'com' donnees.txt 

    \prompt\ \shcmd{grep} 'org' donnees.txt 

    \prompt\ \shcmd{grep} 'com\textbackslash|org' donnees.txt 

    \prompt\ \shcmd{grep} -E 'com|org' donnees.txt 

    \prompt\ \shcmd{grep} -E 'com|org|fr' donnees.txt 
    \end{terminal}

    \begin{infobox}
    Avec \texttt{grep} (regex basiques), l'alternative (signifie ``ou'') s'écrit \texttt{\textbackslash|}.
    Avec \texttt{grep -E} (regex étendues), on écrit directement \texttt{|}.
    \end{infobox}

    % ---

    \item Analysez les résultats des commandes suivantes :
    \begin{terminal}
    \prompt\ \shcmd{grep} -E 'date: 2021|2022' donnees.txt

    \prompt\ \shcmd{grep} -E 'date: (2021|2022)' donnees.txt

    \prompt\ \shcmd{grep} 'date: \textbackslash(2021\textbackslash|2022\textbackslash)' donnees.txt

    \prompt\ \shcmd{grep} -E 'date: (2021|2022|2023)' donnees.txt
    \end{terminal}

    \begin{infobox}
    Avec \texttt{grep -E}, \texttt{( )} servent à regrouper les alternatives.
    Avec \texttt{grep} (sans \texttt{-E}), il faut échapper ces symboles : 
    \texttt{\textbackslash( \texttt{\textbackslash|} \textbackslash)}.
    \end{infobox}
\end{itemize}






\end{document}
