\documentclass[11pt,a4paper]{article}

\usepackage[T1]{fontenc}
\usepackage[french]{babel}
\usepackage{geometry}

\usepackage{../../ldsstyle}

\geometry{margin=2.5cm}

\title{TD4 -- Langages de script}
\author{Abdallah Ammar}
\date{\today}

\begin{document}
\maketitle















% --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---


\section{Analyse de données}


\begin{enumerate}

    \item Créez le répertoire \texttt{TD4} dans votre répertoire 
          personnel (\texttt{\$HOME}), puis le sous-répertoire \texttt{Q1} 
          dans \texttt{TD4}.
          Placez-vous ensuite dans le répertoire \texttt{Q1}.

    % ---

    \item Nous allons maintenant télécharger un fichier contenant des données 
          personnelles relatives aux employés.

    \begin{terminal}
    \prompt\ \tcomment{URL du fichier à télécharger}

    \prompt\ UrlGit="https://raw.githubusercontent.com/AbdAmmar/LDS/main"

    \prompt\ Rep="TD/TD4/data/employes.csv"

    \prompt\

    \prompt\ \tcomment{Téléchargement du fichier}

    \prompt\ \shcmd{curl} -o employes.csv "\$\{UrlGit\}/\$\{Rep\}"
    
    \prompt\

    \prompt\ \tcomment{Vérifiez que le fichier a bien été téléchargé}

    \prompt\ \shcmd{ls} employes.csv
    \end{terminal}

    % ---

    \item Affichez le contenu du fichier \texttt{employes.csv} et identifiez le séparateur utilisé.

    \begin{terminal}
    \prompt\ \shcmd{cat} employes.csv
    \end{terminal}

    % ---

    \item À l'aide des commandes \texttt{cat} et \texttt{wc}, affichez le nombre de lignes
    contenues dans le fichier \texttt{employes.csv}.

    \begin{terminal}
    \prompt\ \shcmd{cat} employes.csv | \shcmd{wc} -l
    \end{terminal}

    \begin{infobox}
    Le symbole \texttt{|} (pipe) permet d'envoyer la sortie d'une commande
    directement en entrée d'une autre commande.
    Ici, la sortie de \texttt{cat} est transmise à \texttt{wc}.
    \end{infobox}

    % ---

    \item Analysez les résultats des commandes suivantes :

    \begin{terminal}
    \prompt\ \shcmd{cut} -d';' -f1 employes.csv

    \prompt\ \shcmd{cut} -d';' -f2 employes.csv

    \prompt\ \shcmd{cut} -d';' -f1,2 employes.csv

    \prompt\ \shcmd{cut} -d';' -f2,1 employes.csv

    \prompt\ \shcmd{cut} -d';' -f2,4 employes.csv

    \prompt\ \shcmd{cut} -d';' -f2,3 employes.csv

    \prompt\ \shcmd{cut} -d';' -f2,3,4 employes.csv

    \prompt\ \shcmd{cut} -d';' -f2,4,3 employes.csv

    \prompt\ \shcmd{cut} -d';' -f2-4 employes.csv

    \prompt\ \shcmd{cut} -d';' -f2- employes.csv
    \end{terminal}

    \begin{infobox}
    La commande \texttt{cut} permet d'extraire des colonnes d'un fichier texte.
    L'option \texttt{-d} indique le séparateur utilisé entre les champs,
    et l'option \texttt{-f} précise le ou les champs à afficher.
    Les champs sont numérotés à partir de \texttt{1}.
    \end{infobox}

    % ---

    \item Analysez les résultats des commandes suivantes :

    \begin{terminal}
    \prompt\ \shcmd{cut} -d';' -f1- employes.csv 

    \prompt\ \shcmd{cut} -d';' -f1- employes.csv {-}{-}output-delimiter=','

    \prompt\ \shcmd{cut} -d';' -f1- employes.csv {-}{-}output-delimiter=' '

    \prompt\ \shcmd{cut} -d';' -f1- employes.csv {-}{-}output-delimiter='-'

    \prompt\ \shcmd{cut} -d';' -f1- employes.csv {-}{-}output-delimiter='{-}{-}'

    \prompt\ \shcmd{cut} -d';' -f1- employes.csv {-}{-}output-delimiter='{-}{+}{-}'
    \end{terminal}

    \begin{infobox}
    L'option \texttt{--output-delimiter} permet de définir le séparateur utilisé
    pour l'affichage des champs en sortie.
    Elle ne modifie pas le fichier d'origine.
    \end{infobox}

    % ---

    \item Analysez les résultats des commandes suivantes :

    \begin{terminal}
    \prompt\ \shcmd{cat} employes.csv | \shcmd{tr} ';' ' '
    
    \prompt\ \shcmd{cat} employes.csv | \shcmd{tr} ';' ','
    
    \prompt\ \shcmd{cat} employes.csv | \shcmd{tr} ';' '-'
    
    \prompt\ \shcmd{cat} employes.csv | \shcmd{tr} ';' '--'
    
    \prompt\ \shcmd{cat} employes.csv | \shcmd{tr} '[:lower:]' '[:upper:]'
    
    \prompt\ \shcmd{cat} employes.csv | \shcmd{tr} '[:upper:]' '[:lower:]'
    
    \prompt\ \shcmd{cat} employes.csv | \shcmd{tr} -d ';'
    
    \prompt\ \shcmd{cat} employes.csv | \shcmd{tr} -d '\textbackslash n'
    \end{terminal}

    \begin{infobox}
    La commande \texttt{tr} (translate) remplace ou supprime des caractères :
    \begin{itemize}
        \item \texttt{tr 'A' 'B'} : remplace chaque \texttt{A} par \texttt{B}.
        \item \texttt{tr -d 'A'} : supprime chaque \texttt{A}.
        \item \texttt{tr '[:lower:]' '[:upper:]'} : convertit les minuscules en majuscules.
    \end{itemize}
    \end{infobox}

    % ---

    \item Affichez uniquement le prénom et le nom des employés qui travaillent à \texttt{Paris}.

    \begin{terminal}
    \prompt\ \shcmd{grep} 'Paris' employes.csv | \shcmd{cut} -d';' -f2,3
    \end{terminal}

    % ---

    \item Afin d'ignorer la ligne d'en-tête du fichier (qui commence par \texttt{id}),
    utilisez la commande \texttt{grep} pour exclure cette ligne, puis affichez
    le prénom et le nom des employés.

    \begin{terminal}
    \prompt\ \shcmd{grep} -v '\^{}id' employes.csv | \shcmd{cut} -d';' -f2,3
    \end{terminal}

    % ---

    \item Générer un nouveau fichier \texttt{employes2.csv} contenant les données du 
    fichier \texttt{employes.csv}, mais sans la ligne d'en-tête de ce dernier.

    \begin{terminal}
    \prompt\ \shcmd{grep} -v '\^{}id' employes.csv > employes2.csv

    \prompt

    \prompt\ \tcomment{Vérifiez le nouveau fichier}

    \prompt\ \shcmd{cat} employes2.csv
    \end{terminal}

    \begin{infobox}
    L'opérateur \texttt{>} permet de rediriger la sortie standard d'une commande 
    vers un fichier. Si le fichier cible existe déjà, son contenu sera écrasé. 
    Pour ajouter le résultat à la fin du fichier sans l'écraser, utilisez l'opérateur \texttt{>>}.
    \end{infobox}

    % ---

    \item Analysez les résultats des commandes suivantes :

    \begin{terminal}
    \prompt\ \shcmd{cut} -d';' -f3- employes2.csv

    \prompt\ \shcmd{cut} -d';' -f3- employes2.csv | \shcmd{sort}

    \prompt\ \shcmd{cut} -d';' -f3- employes2.csv | \shcmd{sort} -r
    \end{terminal}

    \begin{infobox}
    Par défaut, la commande \texttt{sort} trie les lignes par ordre alphabétique.
    L'option \texttt{-r} permet d'inverser l'ordre du tri.
    \end{infobox}

    % ---

    \item Analysez les résultats des commandes suivantes :

    \begin{terminal}
    \prompt\ \shcmd{cut} -d';' -f1- employes2.csv | \shcmd{sort}

    \prompt\ \shcmd{cut} -d';' -f1- employes2.csv | \shcmd{sort} -n

    \prompt\ \shcmd{cut} -d';' -f1- employes2.csv | \shcmd{sort} -nr
    \end{terminal}

    \begin{infobox}
    Sans option, \texttt{sort} effectue un tri alphabétique.
    L'option \texttt{-n} permet de trier les valeurs comme des nombres.
    L'option \texttt{-r} inverse l'ordre du tri.
    \end{infobox}

    % ---

    \item Analysez les résultats des commandes suivantes :

    \begin{terminal}
    \prompt\ \shcmd{cut} -d';' -f3- employes2.csv | \shcmd{sort} -t';' 

    \prompt\ \shcmd{cut} -d';' -f3- employes2.csv | \shcmd{sort} -t';' -k1

    \prompt\ \shcmd{cut} -d';' -f3- employes2.csv | \shcmd{sort} -t';' -k2

    \prompt\ \shcmd{cut} -d';' -f3- employes2.csv | \shcmd{sort} -t';' -k3
    \end{terminal}

    \begin{infobox}
    Par défaut, \texttt{sort} trie les lignes selon le premier champ.
    L'option \texttt{-t} permet de définir le séparateur de champs,
    et l'option \texttt{-kN} permet de choisir le champ utilisé pour le tri,
    où \texttt{N} correspond au numéro du champ.
    \end{infobox}

    % ---

    \item Analysez le résultat des commandes suivantes :

    \begin{terminal}
    \prompt\ \shcmd{cut} -d';' -f4 employes2.csv

    \prompt\ \shcmd{cut} -d';' -f4 employes2.csv | \shcmd{uniq}

    \prompt\ \shcmd{cut} -d';' -f4 employes2.csv | \shcmd{sort} | \shcmd{uniq}

    \prompt\ \shcmd{cut} -d';' -f4 employes2.csv | \shcmd{uniq} -c

    \prompt\ \shcmd{cut} -d';' -f4 employes2.csv | \shcmd{sort} | \shcmd{uniq} -c
    \end{terminal}

    \begin{infobox}
    La commande \texttt{uniq} supprime uniquement les lignes consécutives identiques.
    Si les lignes identiques ne sont pas côte à côte, elles ne seront pas supprimées.
    Pour utiliser correctement \texttt{uniq}, souvent il est nécessaire de trier les
    données au préalable à l'aide de \texttt{sort}.

    L'option \texttt{-c} de \texttt{uniq} permet d'afficher le nombre d'occurrences
    de chaque ligne.
    \end{infobox}

    % ---

    \item Combinez les commandes étudiées précédemment avec \texttt{>} afin de rediriger les résultats 
    et générer les fichiers suivants :
    \begin{itemize}
        \item \texttt{employes\_id.csv} : fichier contenant les données triées par numéro d'identité ;
        \item \texttt{employes\_nom.csv} : fichier contenant les données triées par nom ;
        \item \texttt{employes\_ville.csv} : fichier contenant les données triées par nom de ville.
    \end{itemize}
    Les résultats doivent être séparés par un espace, et non par ``\texttt{;}''.

    \begin{terminal}
        \prompt\ \shcmd{cut} -d';' -f1- employes2.csv {-}{-}output-delimiter=' ' \textbackslash

        \prompt\ \hspace{0.5cm} | \shcmd{sort} -nt' ' -k1 > employes\_id.csv

        \prompt

        \prompt\ \shcmd{cut} -d';' -f1- employes2.csv {-}{-}output-delimiter=' ' \textbackslash

        \prompt\ \hspace{0.5cm} | \shcmd{sort} -t' ' -k3 > employes\_nom.csv

        \prompt

        \prompt\ \shcmd{cut} -d';' -f1- employes2.csv {-}{-}output-delimiter=' ' \textbackslash

        \prompt\ \hspace{0.5cm} | \shcmd{sort} -t' ' -k6 > employes\_ville.csv
    \end{terminal}

    \begin{infobox}
    Le caractère \texttt{\textbackslash} à la fin d'une ligne permet d'indiquer au shell que 
    la commande se poursuit sur la ligne suivante. Cela améliore la lisibilité des commandes 
    longues ou complexes en les divisant en plusieurs lignes.
    \end{infobox}

    % ---

    \item Combinez les commandes vues précédemment afin d'afficher les villes de l'entreprise,
    triées par nombre d'employés décroissant.

    \begin{terminal}
    \prompt\ \shcmd{cut} -d';' -f6 employes2.csv | \shcmd{sort} | \shcmd{uniq} -c | \shcmd{sort} -nr
    \end{terminal}

\end{enumerate}



% --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---




\section{Nombre décimaux}

\begin{enumerate}

    \item Allez dans le répertoire \texttt{TD4} et créez le sous-répertoire \texttt{Q2}.
    Placez-vous ensuite dans le répertoire \texttt{Q2}.

    % ---

    \item Analysez les résultats des commandes suivantes :

    \begin{terminal}
    \prompt\ \shcmd{echo} "\$((4 + 3))"

    \prompt\ \shcmd{echo} "\$((4.5 + 3))"

    \prompt\ \shcmd{echo} "4.5 + 3" | \shcmd{bc}

    \prompt\ \shcmd{echo} "1.5 * 4" | \shcmd{bc}

    \prompt\ \shcmd{echo} "3.34 - 12.21" | \shcmd{bc}
    \end{terminal}
 
    \begin{infobox}
    La commande \texttt{bc} est un outil en ligne de commande permettant d'effectuer des calculs 
    avec des nombres décimaux. Bash ne gère nativement que les entiers.
    \end{infobox}

    % ---

    \item Analysez les résultats des commandes suivantes :

    \begin{terminal}
    \prompt\ \shcmd{echo} "\$((1 / 3))"

    \prompt\ \shcmd{echo} "1 / 3" | \shcmd{bc}

    \prompt\ \shcmd{echo} "scale = 1; 1 / 3" | \shcmd{bc}

    \prompt\ \shcmd{echo} "scale = 2; 1 / 3" | \shcmd{bc}

    \prompt\ \shcmd{echo} "scale = 3; 1 / 3" | \shcmd{bc}
    \end{terminal}

    \begin{infobox}
    L'option \texttt{scale} dans \texttt{bc} permet de définir le nombre de décimales après la 
    virgule dans le résultat.
    Par défaut, \texttt{scale=0}.
    \end{infobox}

    % ---

    \item Analysez les résultats des commandes suivantes :

    \begin{terminal}
    \prompt\ \shcmd{echo} "4 \^{} 2" | \shcmd{bc}

    \prompt\ \shcmd{echo} "4 \^{} 3" | \shcmd{bc}

    \prompt\ \shcmd{echo} "4 \^{} 1.5" | \shcmd{bc}

    \prompt\ \shcmd{echo} "sqrt(4)" | \shcmd{bc}

    \prompt\ \shcmd{echo} "sqrt(4)\^{}3" | \shcmd{bc}

    \prompt\ \shcmd{echo} "sqrt(3)" | \shcmd{bc}

    \prompt\ \shcmd{echo} "scale = 5; sqrt(3)" | \shcmd{bc}
    \end{terminal}

    \begin{infobox}
    Avec \texttt{bc}, l'opérateur \texttt{\^{}} permet de calculer une puissance, et 
    la fonction \texttt{sqrt()} calcule la racine carrée.
    \end{infobox}

    % ---

    \item Analysez les résultats des commandes suivantes :

    \begin{terminal}
    \prompt\ \tcomment{Définition de la constante pi}

    \prompt\ pi=3.1415926535897932

    \prompt\

    \prompt\ \tcomment{Utilisation de la fonction sinus}

    \prompt\ \shcmd{echo} "s(\$\{pi\})" | \shcmd{bc} -l

    \prompt\ \shcmd{echo} "s(\$\{pi\}/2)" | \shcmd{bc} -l

    \prompt\

    \prompt\ \tcomment{Utilisation de la fonction cosinus}

    \prompt\ \shcmd{echo} "c(\$\{pi\})" | \shcmd{bc} -l

    \prompt\ \shcmd{echo} "c(\$\{pi\}/2)" | \shcmd{bc} -l

    \prompt\

    \prompt\ \tcomment{Utilisation de la fonction exponentielle}

    \prompt\ \shcmd{echo} "e(1)" | \shcmd{bc} -l

    \prompt\ \shcmd{echo} "e(0)" | \shcmd{bc} -l

    \prompt\ \shcmd{echo} "e(-1)" | \shcmd{bc} -l

    \prompt\

    \prompt\ \tcomment{Utilisation de la fonction arctangente}

    \prompt\ \shcmd{echo} "a(1)" | \shcmd{bc} -l

    \prompt\ \shcmd{echo} "\$\{pi\} - 4 * a(1)" | \shcmd{bc} -l

    \prompt\

    \prompt\ \tcomment{Utilisation de la fonction logarithme naturel}

    \prompt\ \shcmd{echo} "l(1)" | \shcmd{bc} -l

    \prompt\ \shcmd{echo} "l(e(1))" | \shcmd{bc} -l
    \end{terminal}

    \begin{infobox}
    L'option \texttt{-l} charge la bibliothèque mathématique de \texttt{bc}, permettant l'utilisation des fonctions avancées :
    \texttt{s()} (sinus), \texttt{c()} (cosinus), \texttt{e()} (exponentielle), \texttt{l()} (logarithme naturel), etc.

    Par défaut, avec \texttt{-l}, la précision (\texttt{scale}) est fixée à 20 décimales.
    \end{infobox}

    % ---

    \item Créez un fichier nommé \texttt{moyenne.sh} et ouvrez-le avec votre éditeur de texte préféré.
    Ajoutez le \textit{shebang}, puis insérez une ligne de code pour afficher le message suivant :
    ``\texttt{Ceci est un programme qui calcule la moyenne.}''
    Enfin, rendez le script exécutable et testez-le avec la commande \texttt{./moyenne.sh}.

    % ---

    \item Le script \texttt{moyenne.sh} doit calculer la moyenne des paramètres passés en arguments.
    Modifiez le code pour qu'il retourne un code d'erreur 1 et affiche une message d'erreur si aucun paramètre 
    n'est fourni.

    % ---

    \item Dans un premier temps, le script doit prendre deux arguments, calculer leur somme avec une précision de 2 décimales 
    en utilisant \texttt{bc}, stocker le résultat dans une variable, puis calculer et afficher la moyenne.
    Testez votre code avec \texttt{./moyenne.sh 5.45 3.35}.

\begin{minted}{bash}
SOMME=$(echo "scale = 2; ${1} + ${2}" | bc)
MOYENNE=$(echo "scale = 2; ${SOMME} / 2" | bc)
echo "La moyenne est : ${MOYENNE}"
\end{minted}

    \begin{infobox}
    La syntaxe \texttt{\$(...)} permet de capturer la sortie d'une commande et de la stocker dans une variable.
    C'est une alternative moderne et plus lisible aux backticks (\texttt{` `}).
    \end{infobox}

    % ---

    \item Ajoutez un test sur les deux paramètres pour vérifier qu'ils sont bien des nombres 
    décimaux de la forme \texttt{A.BC}, où :
    \begin{itemize}
        \item \texttt{A} représente un ou plusieurs chiffres,
        \item \texttt{B} et \texttt{C} représentent chacun un chiffre après le point décimal.
    \end{itemize}
    Si l'un des paramètres ne respecte pas ce format, le script doit s'arrêter avec 
    un code d'erreur 2 et afficher un message d'erreur explicite.
    Testez votre code avec
    \begin{itemize}
        \item \texttt{./moyenne.sh 5.45 3.3}.
        \item \texttt{./moyenne.sh 5.4 3.35}.
        \item \texttt{./moyenne.sh 5.45 3.35}.
    \end{itemize}

    Voici un exemple de code pour réaliser cette vérification :

\begin{minted}{bash}
if ! [[ "${1}" =~ ^[0-9]+[\.][0-9]{2}$ ]]; then
    echo "Erreur : '${1}' n'est pas un nombre valide."
    exit 2
fi

if ! [[ "${2}" =~ ^[0-9]+[\.][0-9]{2}$ ]]; then
    echo "Erreur : '${2}' n'est pas un nombre valide."
    exit 2
fi
\end{minted}

    \begin{infobox}
    \texttt{=\textasciitilde} est un opérateur Bash qui permet de comparer une chaîne de caractères à une expression régulière.
    \texttt{[[ "\${variable}" =\textasciitilde regex ]]} retourne \texttt{vrai} si la chaîne correspond à l'expression 
    régulière \texttt{regex}.
    \end{infobox}

    % ---

    \item Plutôt que de tester chaque argument individuellement, modifiez votre script pour utiliser 
    une boucle qui vérifie le format de tous les arguments passés au script.

    Pour cela, utilisez la syntaxe suivante, qui parcourt tous les arguments grâce à \texttt{"\$@"} :

\begin{minted}{bash}
for param in "$@"; do
    if ! [[ "${param}" =~ ^[0-9]+[\.][0-9]{2}$ ]]; then
        echo "Erreur : '${param}' n'est pas un nombre valide."
        exit 2
    fi
done
\end{minted}

    \begin{infobox}
    \texttt{"\$@"} représente la liste complète des arguments (\texttt{\$1}, \texttt{\$2}, etc.).
    \end{infobox}

    % ---

    \item Modifiez votre script pour qu'il calcule la somme de tous les arguments, quel que soit leur nombre.

\end{enumerate}



% --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---




\end{document}
