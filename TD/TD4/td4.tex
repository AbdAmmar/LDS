\documentclass[11pt,a4paper]{article}

\usepackage[T1]{fontenc}
\usepackage[french]{babel}
\usepackage{geometry}

\usepackage{../../ldsstyle}

\usepackage{dirtree}


\geometry{margin=2.5cm}

\title{TD4 -- Langages de script}
\author{Abdallah Ammar}
\date{\today}

\begin{document}
\maketitle















% --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---


\section{Analyse de données}


\begin{enumerate}

    \item Créez le répertoire \texttt{TD4} dans votre répertoire 
          personnel (\texttt{\$HOME}), puis le sous-répertoire \texttt{Q1} 
          dans \texttt{TD4}.
          Placez-vous ensuite dans le répertoire \texttt{Q1}.

    % ---

    \item Nous allons maintenant télécharger un fichier contenant des données 
          personnelles relatives aux employés.

    \begin{terminal}
    \prompt\ \tcomment{URL du fichier à télécharger}

    \prompt\ BASE="https://raw.githubusercontent.com/AbdAmmar/LDS/main"

    \prompt\ FILE="TD/TD4/data/employes.csv"

    \prompt\

    \prompt\ \tcomment{Téléchargement du fichier}

    \prompt\ \shcmd{curl} -LO "\$\{BASE\}/\$\{FILE\}"
    
    \prompt\

    \prompt\ \tcomment{Vérifiez que le fichier a bien été téléchargé}

    \prompt\ \shcmd{ls} employes.csv
    \end{terminal}

    % ---

    \item Affichez le contenu du fichier \texttt{employes.csv} et identifiez le séparateur utilisé.

    \begin{terminal}
    \prompt\ \shcmd{cat} employes.csv
    \end{terminal}

    % ---

    \item À l'aide des commandes \texttt{cat} et \texttt{wc}, affichez le nombre de lignes
    contenues dans le fichier \texttt{employes.csv}.

    \begin{terminal}
    \prompt\ \shcmd{cat} employes.csv | \shcmd{wc} -l
    \end{terminal}

    \begin{infobox}
    Le symbole \texttt{|} (pipe) permet d'envoyer la sortie d'une commande
    directement en entrée d'une autre commande.
    Ici, la sortie de \texttt{cat} est transmise à \texttt{wc}.
    \end{infobox}

    % ---

    \item Analysez les résultats des commandes suivantes :

    \begin{terminal}
    \prompt\ \shcmd{cut} -d';' -f1 employes.csv

    \prompt\ \shcmd{cut} -d';' -f2 employes.csv

    \prompt\ \shcmd{cut} -d';' -f1,2 employes.csv

    \prompt\ \shcmd{cut} -d';' -f2,1 employes.csv

    \prompt\ \shcmd{cut} -d';' -f2,4 employes.csv

    \prompt\ \shcmd{cut} -d';' -f2,3 employes.csv

    \prompt\ \shcmd{cut} -d';' -f2,3,4 employes.csv

    \prompt\ \shcmd{cut} -d';' -f2-4 employes.csv

    \prompt\ \shcmd{cut} -d';' -f2- employes.csv
    \end{terminal}

    \begin{infobox}
    La commande \texttt{cut} permet d'extraire des colonnes d'un fichier texte.
    L'option \texttt{-d} indique le séparateur utilisé entre les champs,
    et l'option \texttt{-f} précise le ou les champs à afficher.
    Les champs sont numérotés à partir de \texttt{1}.
    \end{infobox}

    % ---

% Bash recent
%    \item Analysez les résultats des commandes suivantes :
%
%    \begin{terminal}
%    \prompt\ \shcmd{cut} -d';' -f1- employes.csv 
%
%    \prompt\ \shcmd{cut} -d';' -f1- employes.csv {-}{-}output-delimiter=','
%
%    \prompt\ \shcmd{cut} -d';' -f1- employes.csv {-}{-}output-delimiter=' '
%
%    \prompt\ \shcmd{cut} -d';' -f1- employes.csv {-}{-}output-delimiter='-'
%
%    \prompt\ \shcmd{cut} -d';' -f1- employes.csv {-}{-}output-delimiter='{-}{-}'
%
%    \prompt\ \shcmd{cut} -d';' -f1- employes.csv {-}{-}output-delimiter='{-}{+}{-}'
%    \end{terminal}
%
%    \begin{infobox}
%    L'option \texttt{--output-delimiter} permet de définir le séparateur utilisé
%    pour l'affichage des champs en sortie.
%    Elle ne modifie pas le fichier d'origine.
%    \end{infobox}

    % ---

    \item Analysez les résultats des commandes suivantes :

    \begin{terminal}
    \prompt\ \shcmd{cat} employes.csv | \shcmd{tr} ';' ' '
    
    \prompt\ \shcmd{cat} employes.csv | \shcmd{tr} ';' ','
    
    \prompt\ \shcmd{cat} employes.csv | \shcmd{tr} ';' '-'
    
    \prompt\ \shcmd{cat} employes.csv | \shcmd{tr} ';' '{-}{-}'
    
    \prompt\ \shcmd{cat} employes.csv | \shcmd{tr} '[:lower:]' '[:upper:]'
    
    \prompt\ \shcmd{cat} employes.csv | \shcmd{tr} '[:upper:]' '[:lower:]'
    
    \prompt\ \shcmd{cat} employes.csv | \shcmd{tr} -d ';'
    
    \prompt\ \shcmd{cat} employes.csv | \shcmd{tr} -d '\textbackslash n'

    \prompt\ \shcmd{cat} employes.csv | \shcmd{tr} -d ';' | \shcmd{tr} -d '\textbackslash n'
    \end{terminal}

    \begin{infobox}
    La commande \texttt{tr} (translate) remplace ou supprime des caractères :
    \begin{itemize}
        \item \texttt{tr 'A' 'B'} : remplace chaque \texttt{A} par \texttt{B}.
        \item \texttt{tr -d 'A'} : supprime chaque \texttt{A}.
        \item \texttt{tr '[:lower:]' '[:upper:]'} : convertit les minuscules en majuscules.
    \end{itemize}
    \end{infobox}

    % ---

    \item Affichez uniquement le prénom et le nom des employés qui travaillent à \texttt{Paris}.

    \begin{terminal}
    \prompt\ \shcmd{grep} 'Paris' employes.csv | \shcmd{cut} -d';' -f2,3
    \end{terminal}

    % ---

    \item Afin d'ignorer la ligne d'en-tête du fichier (qui commence par \texttt{id}),
    utilisez la commande \texttt{grep} pour exclure cette ligne, puis affichez
    le prénom et le nom des employés.

    \begin{terminal}
    \prompt\ \shcmd{grep} -v '\^{}id' employes.csv | \shcmd{cut} -d';' -f2,3
    \end{terminal}

    % ---

    \item Générez un nouveau fichier \texttt{employes2.csv} contenant les données du 
    fichier \texttt{employes.csv}, mais sans la ligne d'en-tête de ce dernier.

    \begin{terminal}
    \prompt\ \shcmd{grep} -v '\^{}id' employes.csv > employes2.csv

    \prompt

    \prompt\ \tcomment{Vérifiez le nouveau fichier}

    \prompt\ \shcmd{cat} employes2.csv
    \end{terminal}

    \begin{infobox}
    L'opérateur \texttt{>} permet de rediriger la sortie standard d'une commande 
    vers un fichier. Si le fichier cible existe déjà, son contenu sera écrasé. 
    Pour ajouter le résultat à la fin du fichier sans l'écraser, utilisez l'opérateur \verb|>>|.
    \end{infobox}

    % ---

    \item Analysez les résultats des commandes suivantes :

    \begin{terminal}
    \prompt\ \shcmd{cut} -d';' -f3- employes2.csv

    \prompt\ \shcmd{cut} -d';' -f3- employes2.csv | \shcmd{sort}

    \prompt\ \shcmd{cut} -d';' -f3- employes2.csv | \shcmd{sort} -r
    \end{terminal}

    \begin{infobox}
    Par défaut, la commande \texttt{sort} trie les lignes par ordre alphabétique.
    L'option \texttt{-r} permet d'inverser l'ordre du tri.
    \end{infobox}

    % ---

    \item Analysez les résultats des commandes suivantes :

    \begin{terminal}
    \prompt\ \shcmd{cut} -d';' -f1- employes2.csv | \shcmd{sort}

    \prompt\ \shcmd{cut} -d';' -f1- employes2.csv | \shcmd{sort} -n

    \prompt\ \shcmd{cut} -d';' -f1- employes2.csv | \shcmd{sort} -nr
    \end{terminal}

    \begin{infobox}
    Sans option, \texttt{sort} effectue un tri alphabétique.
    L'option \texttt{-n} permet de trier les valeurs comme des nombres.
    L'option \texttt{-r} inverse l'ordre du tri.
    \end{infobox}

    % ---

    \item Analysez les résultats des commandes suivantes :

    \begin{terminal}
    \prompt\ \shcmd{cut} -d';' -f3- employes2.csv | \shcmd{sort} -t';' 

    \prompt\ \shcmd{cut} -d';' -f3- employes2.csv | \shcmd{sort} -t';' -k1

    \prompt\ \shcmd{cut} -d';' -f3- employes2.csv | \shcmd{sort} -t';' -k2

    \prompt\ \shcmd{cut} -d';' -f3- employes2.csv | \shcmd{sort} -t';' -k3
    \end{terminal}

    \begin{infobox}
    Par défaut, \texttt{sort} trie les lignes selon le premier champ.
    L'option \texttt{-t} permet de définir le séparateur de champs,
    et l'option \texttt{-kN} permet de choisir le champ utilisé pour le tri,
    où \texttt{N} correspond au numéro du champ.
    \end{infobox}

    % ---

    \item Analysez le résultat des commandes suivantes :

    \begin{terminal}
    \prompt\ \shcmd{cut} -d';' -f4 employes2.csv

    \prompt\ \shcmd{cut} -d';' -f4 employes2.csv | \shcmd{uniq}

    \prompt\ \shcmd{cut} -d';' -f4 employes2.csv | \shcmd{sort} | \shcmd{uniq}

    \prompt\ \shcmd{cut} -d';' -f4 employes2.csv | \shcmd{uniq} -c

    \prompt\ \shcmd{cut} -d';' -f4 employes2.csv | \shcmd{sort} | \shcmd{uniq} -c
    \end{terminal}

    \begin{infobox}
    La commande \texttt{uniq} supprime uniquement les lignes consécutives identiques.
    Si les lignes identiques ne sont pas côte à côte, elles ne seront pas supprimées.
    Pour utiliser correctement \texttt{uniq}, il est nécessaire souvent de trier les
    données au préalable à l'aide de \texttt{sort}.

    L'option \texttt{-c} de \texttt{uniq} permet d'afficher le nombre d'occurrences
    de chaque ligne.
    \end{infobox}

    % ---

    \item Combinez les commandes étudiées précédemment avec \texttt{>} afin de rediriger les résultats 
    et générer les fichiers suivants :
    \begin{itemize}
        \item \texttt{employes\_id.csv} : fichier contenant les données triées par numéro d'identité ;
        \item \texttt{employes\_nom.csv} : fichier contenant les données triées par nom ;
        \item \texttt{employes\_ville.csv} : fichier contenant les données triées par nom de ville.
    \end{itemize}
    Les résultats doivent être séparés par un espace, et non par ``\texttt{;}''.

    \begin{terminal}
        \prompt\ \shcmd{sort} -nt';' -k1 employes2.csv | \shcmd{tr} ';' ' ' > employes\_id.csv

        \prompt\ \shcmd{sort} -t';' -k3 employes2.csv | \shcmd{tr} ';' ' ' > employes\_nom.csv

        \prompt\ \shcmd{sort} -t';' -k6 employes2.csv | \shcmd{tr} ';' ' ' > employes\_ville.csv
    \end{terminal}

%    \begin{infobox}
%    Le caractère \texttt{\textbackslash} à la fin d'une ligne permet d'indiquer au shell que 
%    la commande se poursuit sur la ligne suivante. Cela améliore la lisibilité des commandes 
%    longues ou complexes en les divisant en plusieurs lignes.
%    \end{infobox}

    % ---

    \item Combinez les commandes vues précédemment afin d'afficher les villes de l'entreprise,
    triées par nombre d'employés décroissant.

    \begin{terminal}
    \prompt\ \shcmd{cut} -d';' -f6 employes2.csv | \shcmd{sort} | \shcmd{uniq} -c | \shcmd{sort} -nr
    \end{terminal}

\end{enumerate}





% --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---






\section{Nombres décimaux}

\begin{enumerate}

    \item Allez dans le répertoire \texttt{TD4} et créez le sous-répertoire \texttt{Q2}.
    Placez-vous ensuite dans le répertoire \texttt{Q2}.

    % ---

    \item Analysez les résultats des commandes suivantes :

    \begin{terminal}
    \prompt\ \shcmd{echo} "\$((4 + 3))"

    \prompt\ \shcmd{echo} "\$((4.5 + 3))"

    \prompt\ \shcmd{echo} "4.5 + 3" | \shcmd{bc}

    \prompt\ \shcmd{echo} "1.5 * 4" | \shcmd{bc}

    \prompt\ \shcmd{echo} "3.34 - 12.21" | \shcmd{bc}
    \end{terminal}
 
    \begin{infobox}
    La commande \texttt{bc} (\textit{Basic Calculator}) est un outil en ligne de 
    commande permettant d'effectuer des calculs avec des nombres décimaux. 
    Bash ne gère nativement que les entiers.
    \end{infobox}

    % ---

    \item Analysez les résultats des commandes suivantes :

    \begin{terminal}
    \prompt\ \shcmd{echo} "\$((1 / 3))"

    \prompt\ \shcmd{echo} "1 / 3" | \shcmd{bc}

    \prompt\ \shcmd{echo} "scale = 1; 1 / 3" | \shcmd{bc}

    \prompt\ \shcmd{echo} "scale = 2; 1 / 3" | \shcmd{bc}

    \prompt\ \shcmd{echo} "scale = 3; 1 / 3" | \shcmd{bc}

    \prompt\ \shcmd{echo} "scale = 5; 1.25 + 1.50" | \shcmd{bc}
    \end{terminal}

    \begin{infobox}
    L'option \texttt{scale} définit la précision des opérations
    produisant des décimales (division, fonctions mathématiques comme
    \texttt{sin}, \texttt{cos}, etc.).
    Elle n'affecte pas l'affichage des additions, soustractions ou multiplications.
    Par défaut, \texttt{scale=0}.
    \end{infobox}

    % ---

    \item Analysez les résultats des commandes suivantes :

    \begin{terminal}
    \prompt\ \shcmd{echo} "4 \^{} 2" | \shcmd{bc}

    \prompt\ \shcmd{echo} "4 \^{} 3" | \shcmd{bc}

    \prompt\ \shcmd{echo} "4 \^{} 1.5" | \shcmd{bc}

    \prompt\ \shcmd{echo} "sqrt(4)" | \shcmd{bc}

    \prompt\ \shcmd{echo} "sqrt(4)\^{}3" | \shcmd{bc}

    \prompt\ \shcmd{echo} "sqrt(3)" | \shcmd{bc}

    \prompt\ \shcmd{echo} "scale = 5; sqrt(3)" | \shcmd{bc}
    \end{terminal}

    \begin{infobox}
    Avec \texttt{bc}, l'opérateur \texttt{\^{}} permet de calculer une puissance, et 
    la fonction \texttt{sqrt()} calcule la racine carrée.
    \end{infobox}

    % ---

    \item Analysez les résultats des commandes suivantes :

    \begin{terminal}
    \prompt\ \tcomment{Définition de la constante pi}

    \prompt\ pi=3.14159265358979323846264

    \prompt\

    \prompt\ \tcomment{Utilisation de la fonction sinus}

    \prompt\ \shcmd{echo} "s(\$\{pi\})" | \shcmd{bc} -l

    \prompt\ \shcmd{echo} "s(\$\{pi\}/2)" | \shcmd{bc} -l

    \prompt\

    \prompt\ \tcomment{Utilisation de la fonction cosinus}

    \prompt\ \shcmd{echo} "c(\$\{pi\})" | \shcmd{bc} -l

    \prompt\ \shcmd{echo} "c(\$\{pi\}/2)" | \shcmd{bc} -l

    \prompt\

    \prompt\ \tcomment{Utilisation de la fonction exponentielle}

    \prompt\ \shcmd{echo} "e(1)" | \shcmd{bc} -l

    \prompt\ \shcmd{echo} "e(0)" | \shcmd{bc} -l

    \prompt\ \shcmd{echo} "e(-1)" | \shcmd{bc} -l

    \prompt\

    \prompt\ \tcomment{Utilisation de la fonction arctangente}

    \prompt\ \shcmd{echo} "a(1)" | \shcmd{bc} -l

    \prompt\ \shcmd{echo} "\$\{pi\} - 4 * a(1)" | \shcmd{bc} -l

    \prompt\

    \prompt\ \tcomment{Utilisation de la fonction logarithme naturel}

    \prompt\ \shcmd{echo} "l(1)" | \shcmd{bc} -l

    \prompt\ \shcmd{echo} "l(e(1))" | \shcmd{bc} -l
    \end{terminal}

    \begin{infobox}
    L'option \texttt{-l} charge la bibliothèque mathématique de \texttt{bc}, permettant l'utilisation des fonctions avancées :
    \texttt{s()} (sinus), \texttt{c()} (cosinus), \texttt{e()} (exponentielle), \texttt{l()} (logarithme naturel), etc.

    Par défaut, avec \texttt{-l}, la précision (\texttt{scale}) est fixée à 20 décimales.
    \end{infobox}

    % ---

    \item Créez un fichier nommé \texttt{moyenne.sh} et ouvrez-le avec votre éditeur de texte préféré.
    Ajoutez le \textit{Shebang}, puis insérez une ligne de code pour afficher le message suivant :
    ``\texttt{Ceci est un script qui calcule la moyenne.}''
    Enfin, rendez le script exécutable et testez-le avec la commande \texttt{./moyenne.sh}.

    % ---

    \item Le script \texttt{moyenne.sh} doit calculer la moyenne des paramètres passés en arguments.
    Modifiez le script pour qu'il retourne un code d'erreur 1 et affiche un message d'erreur si aucun paramètre 
    n'est fourni.

    % ---

    \item Dans un premier temps, le script doit prendre deux arguments, calculer leur somme avec une précision de 2 décimales 
    en utilisant \texttt{bc}, stocker le résultat dans une variable, puis calculer et afficher la moyenne.
    Testez votre script avec \texttt{./moyenne.sh 5.45 3.35}.

\begin{minted}{bash}
SOMME=$(echo "scale = 2; ${1} + ${2}" | bc)
MOYENNE=$(echo "scale = 2; ${SOMME} / 2" | bc)
echo "La moyenne est : ${MOYENNE}"
\end{minted}

    \begin{infobox}
    La syntaxe \texttt{\$(...)} permet de capturer la sortie d'une commande et de la stocker dans une variable.
    C'est une alternative moderne et plus lisible aux backticks (\texttt{` `}).
    \end{infobox}

    % ---

    \item Ajoutez un test sur les deux paramètres pour vérifier qu'ils sont bien des nombres 
    décimaux de la forme \texttt{A.BC}, où :
    \begin{itemize}
        \item \texttt{A} représente un ou plusieurs chiffres,
        \item \texttt{B} et \texttt{C} représentent chacun un chiffre après le point décimal.
    \end{itemize}
    Si l'un des paramètres ne respecte pas ce format, le script doit s'arrêter avec 
    un code d'erreur 2 et afficher un message d'erreur explicite.
    Testez votre script avec
    \begin{itemize}
        \item \texttt{./moyenne.sh 5.45 3.3}
        \item \texttt{./moyenne.sh 5.4 3.35}
        \item \texttt{./moyenne.sh 5.45 3.35}
    \end{itemize}

    Voici un exemple de script pour réaliser cette vérification :

\begin{minted}{bash}
if ! [[ "${1}" =~ ^[0-9]+[.][0-9]{2}$ ]]; then
    echo "Erreur : '${1}' n'est pas un nombre valide."
    exit 2
fi

if ! [[ "${2}" =~ ^[0-9]+[.][0-9]{2}$ ]]; then
    echo "Erreur : '${2}' n'est pas un nombre valide."
    exit 2
fi
\end{minted}

    \begin{infobox}
    \texttt{=\textasciitilde} est un opérateur Bash qui permet de comparer une chaîne de caractères à une expression régulière.
    \texttt{[[ "\${variable}" =\textasciitilde regex ]]} retourne \texttt{vrai} si la chaîne correspond à l'expression 
    régulière \texttt{regex}.
    \end{infobox}

    \begin{infobox}
    Le caractère \texttt{.} signifie ``n'importe quel caractère''.
    Pour cibler littéralement un point (le séparateur décimal), il faut l'échapper :
    \begin{itemize}
        \item \texttt{\textbackslash.} : L'antislash désactive le sens spécial du point.
        \item \texttt{[.]} : De manière générale, à l'intérieur des crochets \texttt{[]}, 
        les caractères spéciaux (comme \texttt{.}, \texttt{*} ou \texttt{+}) perdent leur signification 
        et redeviennent de simples caractères littéraux.
    \end{itemize}
    Évitez la syntaxe \texttt{[\textbackslash.]}, car elle est ambiguë et peut être interprétée 
    comme ``un point ou un antislash''.
    \end{infobox}

    % ---

    \item Plutôt que de tester chaque argument individuellement, modifiez votre script pour utiliser 
    une boucle qui vérifie le format de tous les arguments passés au script.

    Pour cela, utilisez la syntaxe suivante, qui parcourt tous les arguments grâce à \texttt{"\$@"} :

\begin{minted}{bash}
for param in "$@"; do
    if ! [[ "${param}" =~ ^[0-9]+[.][0-9]{2}$ ]]; then
        echo "Erreur : '${param}' n'est pas un nombre valide."
        exit 2
    fi
done
\end{minted}

    \begin{infobox}
    \texttt{"\$@"} représente la liste complète des arguments (\texttt{\$1}, \texttt{\$2}, etc.).
    \end{infobox}

    % ---

    \item Modifiez votre script pour qu'il calcule la moyenne de tous les arguments, quel que soit leur nombre.

    % ---

    \item En français, la convention typographique impose d'utiliser la virgule~\texttt{,} comme séparateur décimal 
    dans les nombres, tandis que le point~\texttt{.} sert de séparateur de milliers. Modifiez votre script afin que 
    les arguments soient saisis sous la forme \texttt{A,BC}. Assurez-vous de convertir correctement ces arguments 
    au format \texttt{A.BC} (par exemple, en utilisant la commande \texttt{tr}) avant d'effectuer le calcul de la moyenne.
    Le résultat affiché doit également respecter la convention française.

\end{enumerate}



% --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---





\section{Décodage du code couleur des résistances}

Les résistances électriques sont trop petites pour y imprimer directement leur valeur. 
Pour résoudre ce problème, les fabricants utilisent un code couleur standardisé composé 
de bandes colorées. Chaque couleur correspond à un chiffre ou à un multiplicateur précis.

\noindent
Le tableau ci-dessous présente la correspondance entre les couleurs et les chiffres :
\begin{center}
\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|}
    \hline
    \textbf{Noir} & \textbf{Marron} & \textbf{Rouge} & \textbf{Orange} & \textbf{Jaune} & \textbf{Vert} & \textbf{Bleu} & \textbf{Violet} & \textbf{Gris} & \textbf{Blanc} \\
    \hline
    0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 \\
    \hline
\end{tabular}
\end{center}

\noindent
Le principe de lecture est le suivant :
\begin{itemize}
    \item Les deux premières bandes forment la valeur principale (un nombre à deux chiffres).
    \item La troisième bande indique le nombre de zéros à ajouter à cette valeur principale.
\end{itemize}

\noindent
La valeur de la résistance, exprimée en \texttt{ohms}, est obtenue en multipliant la valeur 
principale par $10^n$, où $n$ est le nombre de zéros indiqué par la troisième bande.

\medskip
\noindent
Exemples :
\begin{itemize}
    \item Marron-orange-noir : valeur principale = 13, nombre de zéros = 0 $\Rightarrow$ $13 \times 10^0 = 13$ ohms.
    \item Marron-orange-rouge : valeur principale = 13, nombre de zéros = 2 $\Rightarrow$ $13 \times 10^2 = 1300$ ohms.
    \item Marron-orange-jaune : valeur principale = 13, nombre de zéros = 4 $\Rightarrow$ $13 \times 10^4 = 130000$ ohms.
\end{itemize}

Dans cet exercice, vous allez concevoir un script qui permet de décoder automatiquement 
la valeur d'une résistance à partir de ses trois bandes de couleur, évitant ainsi d'avoir 
à mémoriser ce code.
\begin{enumerate}

    \item Revenez dans le répertoire \texttt{TD4} et créez le sous-répertoire \texttt{Q3}.
    Placez-vous ensuite dans le répertoire \texttt{Q3}.

    Créez un fichier nommé \texttt{calc\_resistance.sh} et ouvrez-le avec votre éditeur de texte préféré.
    Ajoutez le \textit{Shebang}, puis insérez une ligne de code pour afficher le message suivant :
    \texttt{Ceci est un script qui calcule la valeur d'une résistance électrique.}
    Rendez le script exécutable et testez-le avec la commande \texttt{./calc\_resistance.sh}.

    % ---

    \item Créez une fonction \texttt{obt\_val\_coul} qui prend en argument une couleur et retourne la
    valeur numérique correspondante. 
    
    Le script doit être capable de reconnaître les couleurs qu'elles soient écrites en minuscules 
    ou avec une majuscule initiale (ex: \texttt{rouge} ou \texttt{Rouge}).
    
    Si l'argument fourni ne correspond à aucune couleur valide, la fonction doit afficher 
    le message : \texttt{Couleur invalide}.

\begin{minted}{bash}
obt_val_coul() {
    case ${1} in
        [Nn]oir)
            echo "0";;
        [Mm]arron)
            echo "1";;
        [Rr]ouge)
            echo "2";;
        [Oo]range)
            echo "3";;
        [Jj]aune)
            echo "4";;
        [Vv]ert)
            echo "5";;
        [Bb]leu)
            echo "6";;
        [Vv]iolet)
            echo "7";;
        [Gg]ris)
            echo "8";;
        [Bb]lanc)
            echo "9";;
        *)
            echo "Couleur invalide"
    esac
}
\end{minted}

    \begin{infobox}
    La structure \texttt{case} permet de comparer une variable à plusieurs motifs :
    \begin{itemize}
        \item Chaque motif se termine par \texttt{;;}.
        \item Le bloc se termine par \texttt{esac}.
        \item On utilise \texttt{*)} pour un cas par défaut.
    \end{itemize}
    \end{infobox}

    \begin{infobox}
    Dans un motif \texttt{case}, les crochets \texttt{[]} permettent de spécifier une liste de caractères possibles.
    Par exemple, \texttt{[Rr]ouge} reconnaîtra \texttt{Rouge} et \texttt{rouge}.
    \end{infobox}

    % ---

    \item Modifiez le script afin qu'il vérifie que le nombre d'arguments fournis 
    est exactement égal à 3.
    Si ce n'est pas le cas, le script doit s'arrêter avec un code de retour égal à 1 et afficher 
    le message d'erreur suivant :
    \texttt{Erreur : le nombre de couleurs spécifié est invalide.}

    % ---

    \item Dans le corps principal du script, récupérez les valeurs des trois couleurs passées en arguments 
    en appelant la fonction \texttt{obt\_val\_coul}.

\begin{minted}{bash}
# Exemple de récupération de la première couleur
VAL1=$(obt_val_coul "${1}")
\end{minted}

    \begin{infobox}
    La fonction \texttt{obt\_val\_coul} retourne sa valeur via \texttt{echo}.
    Cela signifie que le résultat est affiché directement dans la sortie standard.
    Pour récupérer cette valeur dans une variable, utilisez la substitution de commande :
    \texttt{valeur=\$(obt\_val\_coul "couleur")}. 
    \end{infobox}

    % ---

    \item Avant de procéder au calcul, vérifiez pour chaque résultat qu'il s'agit bien d'un nombre (compris entre 0 et 9). 
    Si l'un des résultats est le message \texttt{Couleur invalide}, le script doit s'arrêter 
    immédiatement avec un code d'erreur 2 et afficher un message explicite à l'utilisateur.

\begin{minted}{bash}
# Exemple de vérification pour la première couleur
if [[ "${VAL1}" == "Couleur invalide" ]]; then
    echo "Erreur : La couleur '${1}' n'est pas reconnue."
    exit 2
fi
\end{minted}

    % ---

    \item Modifiez le code pour qu'il calcule et affiche la valeur finale de la résistance.
    Testez votre script avec \texttt{calc\_resistance.sh "marron" "noir" "orange"} (Doit afficher 10000).

    \begin{infobox}
    Pour calculer une puissance en Bash, vous pouvez utiliser l'opérateur \texttt{**} 
    dans un bloc arithmétique ou la commande \texttt{bc}.
    \end{infobox}

\end{enumerate}



% --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---





\section{Projet}

Les exercices suivants constituent le projet de ce TD. Vous devez vous placer dans le 
répertoire \texttt{TD4} et créer un sous-répertoire nommé \texttt{Q4} pour y effectuer 
votre travail.

Dans ce répertoire, vous allez concevoir trois scripts Bash. Tous les scripts déposés 
sur Arche doivent respecter les deux conditions suivantes :
\begin{itemize}
    \item Commencer par le \textit{Shebang} approprié.

    \item Posséder les droits d'exécution.
\end{itemize}

Les modalités de dépôt et de nommage de l'archive sont détaillées dans la dernière section de ce document.

% ---

\subsection{Scrabble}

Le Scrabble est un jeu de lettres où les joueurs placent des lettres sur un plateau afin 
de former des mots. Chaque lettre possède une valeur numérique, et le score d'un mot 
correspond à la somme des valeurs de ses lettres.

Votre tâche consiste à créer un script nommé \texttt{scrabble.sh} qui calcule le score d'un 
mot passé en argument, en additionnant les valeurs de ses lettres.

Voici les valeurs associées à chaque lettre :
\begin{center}
\begin{tabular}{|c|c|c|c|c|c|c|c|}
    \hline
    \textbf{Lettres} & A, E, I, O, U, L, N, R, S, T & D, G & B, C, M, P & F, H, V, W, Y & K & J, X & Q, Z \\
    \hline
    \textbf{Valeur}  & 1 & 2 & 3 & 4 & 5 & 8 & 10 \\
    \hline
\end{tabular}
\end{center}

Le script doit respecter les contraintes suivantes :
\begin{itemize}
    \item Vérifier que le nombre de paramètres est exactement égal à un. 
    Si ce n'est pas le cas, afficher un message d'erreur et quitter le 
    script avec un code de retour égal à 1.

    \item Vérifier que l'argument fourni ne contient que des lettres 
    (majuscules ou minuscules). Si ce n'est pas le cas, afficher un 
    message d'erreur et quitter le script avec un code de retour égal à 2.
\end{itemize}

% ---

\subsection{Restructuration du Système d'Archivage RH}

Une entreprise centralise ses documents RH dans un dossier de réception. Actuellement, 
ce dossier est un véritable chaos numérique. Votre mission consiste à automatiser le 
tri de ces fichiers à l'aide de scripts Bash et de la puissance du \texttt{globbing}.

Vous devez effectuer ces actions exclusivement avec la commande \texttt{mv} et
les métacaractères (\texttt{*}, \texttt{?}, \texttt{[]}, \texttt{\{\}}, etc.).

\begin{itemize}
    \item Avant de traiter les données, créez l'arborescence cible dans votre 
     répertoire \texttt{Q4}. Elle doit scrupuleusement respecter la structure suivante :
    \begin{center}
    \begin{minipage}{0.8\textwidth}
    \dirtree{%
    .1 org\_rh/.
    .2 Archives/.
    .2 Old\_Formats/.
    .2 Production/.
    .3 Direction/.
    .3 Erreurs/.
    .3 Paye/.
    }
    \end{minipage}
    \end{center}

    % ---

    \item Le dossier de réception contient plus de 300 fichiers ; le tri manuel est donc 
    strictement proscrit. Récupérez et extrayez l'archive via \texttt{curl} et \texttt{tar} :

    \begin{terminal}
    \prompt\ BASE="https://raw.githubusercontent.com/AbdAmmar/LDS/main"

    \prompt\ FILE="TD/TD4/data/vrac\_rh.tar.gz"

    \prompt\ \shcmd{curl} -LO "\$\{BASE\}/\$\{FILE\}"

    \prompt

    \prompt\ \tcomment{Extraction de l'archive tarball}

    \prompt\ \shcmd{tar} -xzvf vrac\_rh.tar.gz

    \prompt

    \prompt\ \tcomment{Vérification des fichiers}

    \prompt\ \shcmd{ls} vrac\_rh
    \end{terminal}

    % ---

    \item Testez toujours votre sélection avec \texttt{ls pattern} avant de valider le déplacement avec \texttt{mv}.
    Les fichiers valides respectent le format suivant : \\
    \texttt{ANNÉE(4)MOIS(2)\_NOM\_SERVICE\_TYPE.extension} \\
    \textit{Exemple : \texttt{202510\_DUBOIS\_SALES\_FDP.pdf}}

    \begin{enumerate}
        \item Déplacez la totalité des fichiers de l'année 2024 (quels que soient le mois ou le type) vers : \\
        \texttt{org\_rh/Archives/}.

        % ---

        \item Identifiez les documents contenant le mot-clé \texttt{DIR} et 
        transférez-les vers : \\
        \texttt{org\_rh/Production/Direction/}.

        % ---

        \item Déplacez toutes les fiches de paie (\texttt{FDP}) de l'année 2025 vers : \\
        \texttt{org\_rh/Production/Paye/}.

        % ---

        \item Les formats Word sont désormais proscrits. Déplacez tous les fichiers 
        \texttt{.doc} ou \texttt{.docx} vers :\\
        \texttt{org\_rh/Old\_Formats/}.

        % ---

        \item Déplacez tous les fichiers restants (images, fichiers temporaires, 
        erreurs de nommage) vers le dossier : \\
        \texttt{org\_rh/Production/Erreurs/}.
    \end{enumerate}

    % ---

    \item Une fois le dossier \texttt{vrac\_rh} vidé et le tri validé, supprimez le répertoire vide et exportez 
    vos commandes réussies vers un fichier nommé \texttt{solution\_rh.sh}.
    
    Vous pouvez utiliser la commande \texttt{history} pour retrouver vos instructions. Le script final devra 
    être exécutable, commencer par le \textit{Shebang} adéquat et inclure des commentaires clairs pour chaque 
    étape de tri.
\end{itemize}

% ---

\subsection{La Conjecture de Syracuse}

La conjecture de Syracuse (ou suite de Collatz) est une suite mathématique définie 
ainsi : 
\begin{itemize}
    \item On part d'un nombre entier $N > 0$.
    \item S'il est pair, on le divise par 2 ; 
    \item s'il est impair, on le multiplie par 3 et on ajoute 1. 
    \item On recommence ce processus jusqu'à atteindre la valeur 1.
\end{itemize}

Votre mission est de créer un script nommé \texttt{syracuse.sh} dans votre répertoire \texttt{Q4} 
en respectant les consignes suivantes :
\begin{itemize}
    \item Le nombre de départ $N$ doit être récupéré via le premier argument du script.
    \begin{itemize}
        \item Si le script ne reçoit pas exactement un argument, il affiche une erreur 
        et s'interrompt avec le code de retour \texttt{1}.

        \item Si l'argument n'est pas un nombre entier valide (présence de lettres ou de symboles), 
        il affiche une erreur et sort avec le code \texttt{2}.

        \item Si l'argument est un entier inférieur à 1 ($N < 1$), il affiche une 
        erreur et sort avec le code \texttt{3}.
    \end{itemize}

    \item Utilisez une boucle pour calculer les termes successifs jusqu'à atteindre 1. 
    À chaque étape, affichez la valeur actuelle de $N$ et comptabilisez le nombre d'itérations 
    effectuées dans une variable dédiée (compteur).

    Voici un exemple de la sortie attendue :
    \begin{terminal}
    \prompt\ ./syracuse.sh 6

    \prompt\ Décollage avec le nombre 6

    \prompt\ 3 -> 10 -> 5 -> 16 -> 8 -> 4 -> 2 -> Atterrissage à 1 !

    \prompt\ Nombre d'étapes : 8
    \end{terminal}
\end{itemize}

% ---

\subsection{Modalités de dépôt}

Une fois votre travail terminé et testé, replacez-vous dans le répertoire 
parent \texttt{TD4} pour préparer votre archive.

\begin{enumerate}
    \item Utilisez la commande \texttt{tar} pour compresser votre dossier \texttt{Q4} :
    \begin{terminal}
    \prompt\ \shcmd{tar} -czvf Q4\_Prenom\_NOM.tar.gz Q4/
    \end{terminal}

    % ---

    \item Le nom de l'archive est strictement défini :
    \begin{itemize}
        \item Prénom : Première lettre en majuscule, le reste en minuscule (ex: \texttt{Alice}).
        \item NOM : Entièrement en majuscules (ex: \texttt{DUPONT}).
        \item Le nom du fichier ne doit pas contenir d'accents, d'espaces ou de caractères spéciaux. 
        \item Le non-respect de cette nomenclature entraînera une déduction de points.
    \end{itemize}

    \item Si vous travaillez sous WSL, copiez l'archive vers votre bureau Windows 
    pour faciliter le dépôt :
    \begin{terminal}
    \prompt\ \shcmd{cp} Q4\_Prenom\_NOM.tar.gz /mnt/c/Users/VotreNomUtilisateur/Desktop/
    \end{terminal}

    \item Déposez uniquement le fichier \texttt{Q4\_Prenom\_NOM.tar.gz} sur la 
    plateforme Arche avant la date limite.
\end{enumerate}



% --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---




\end{document}
